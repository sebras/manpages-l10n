# French translation of manpages
# This file is distributed under the same license as the manpages-l10n package.
# Copyright © of this file:
# Christophe Blaess <https://www.blaess.fr/christophe/>, 1996-2003.
# Stéphan Rafin <stephan.rafin@laposte.net>, 2002.
# Thierry Vignaud <tvignaud@mandriva.com>, 1999,2002.
# François Micaux, 2002.
# Alain Portal <aportal@univ-montp2.fr>, 2003-2008.
# Jean-Philippe Guérard <fevrier@tigreraye.org>, 2005-2006.
# Jean-Luc Coulon (f5ibh) <jean-luc.coulon@wanadoo.fr>, 2006-2007.
# Julien Cristau <jcristau@debian.org>, 2006-2007.
# Thomas Huriaux <thomas.huriaux@gmail.com>, 2006-2008.
# Nicolas François <nicolas.francois@centraliens.net>, 2006-2008.
# Florentin Duneau <fduneau@gmail.com>, 2006-2010.
# Simon Paillard <simon.paillard@resel.enst-bretagne.fr>, 2006, 2013.
# Denis Barbier <barbier@debian.org>, 2006,2010.
# David Prévot <david@tilapin.org>, 2010, 2013, 2014.
# Cédric Boutillier <cedric.boutillier@gmail.com>, 2011, 2012, 2013.
# Frédéric Hantrais <fhantrais@gmail.com>, 2013, 2014.
# Jean-Philippe MENGUAL <jpmengual@debian.org>, 2021.
msgid ""
msgstr ""
"Project-Id-Version: perkamon\n"
"POT-Creation-Date: 2022-11-14 19:53+0100\n"
"PO-Revision-Date: 2021-06-27 18:17+0200\n"
"Last-Translator: Jean-Philippe MENGUAL <jpmengual@debian.org>\n"
"Language-Team: French <https://translate.holcroft.fr/projects/man-pages-fr/"
"socket/fr/>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n > 1;\n"
"X-Generator: Weblate 3.1.1\n"

#. type: TH
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "SELECT_TUT"
msgstr "SELECT_TUT"

#. type: TH
#: archlinux debian-unstable fedora-rawhide mageia-cauldron
#, no-wrap
msgid "2022-10-09"
msgstr "9 octobre 2022"

#. type: TH
#: archlinux debian-unstable fedora-rawhide mageia-cauldron
#, no-wrap
msgid "Linux man-pages 6.01"
msgstr "Pages du manuel de Linux 6.01"

#. type: SH
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "NAME"
msgstr "NOM"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-tumbleweed
msgid "select, pselect - synchronous I/O multiplexing"
msgstr "select, pselect - Multiplexage d'entrées-sorties synchrones"

#. type: SH
#: archlinux debian-unstable fedora-rawhide mageia-cauldron
#, no-wrap
msgid "LIBRARY"
msgstr "BIBLIOTHÈQUE"

#. type: Plain text
#: archlinux debian-unstable fedora-rawhide mageia-cauldron
msgid "Standard C library (I<libc>, I<-lc>)"
msgstr "Bibliothèque C standard (I<libc>, I<-lc>)"

#. type: SH
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "SYNOPSIS"
msgstr "SYNOPSIS"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-tumbleweed
msgid "See B<select>(2)"
msgstr "Voir B<select>(2)"

#. type: SH
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "DESCRIPTION"
msgstr "DESCRIPTION"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-tumbleweed
msgid ""
"The B<select>()  and B<pselect>()  system calls are used to efficiently "
"monitor multiple file descriptors, to see if any of them is, or becomes, "
"\"ready\"; that is, to see whether I/O becomes possible, or an \"exceptional "
"condition\" has occurred on any of the file descriptors."
msgstr ""
"Les appels système B<select>() et B<pselect>()) sont utilisés pour "
"superviser efficacement plusieurs descripteurs de fichiers pour vérifier si "
"l'un d'entre eux est ou devient « prêt » ; c'est-à-dire savoir si des "
"entrées-sorties deviennent possibles ou si une « condition exceptionnelle » "
"est survenue sur l'un des descripteurs."

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-tumbleweed
msgid ""
"This page provides background and tutorial information on the use of these "
"system calls.  For details of the arguments and semantics of B<select>()  "
"and B<pselect>(), see B<select>(2)."
msgstr ""
"Cette page fournit des informations de contexte et des tutoriels sur "
"l'utilisation de ces appels système. Pour des détails sur les paramètres et "
"la sémantique de B<select>() et de B<pselect>(), voir B<select>(2)."

#. type: SS
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "Combining signal and data events"
msgstr "Combinaison d'événements de signaux et de données"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-tumbleweed
msgid ""
"B<pselect>()  is useful if you are waiting for a signal as well as for file "
"descriptor(s) to become ready for I/O.  Programs that receive signals "
"normally use the signal handler only to raise a global flag.  The global "
"flag will indicate that the event must be processed in the main loop of the "
"program.  A signal will cause the B<select>()  (or B<pselect>())  call to "
"return with I<errno> set to B<EINTR>.  This behavior is essential so that "
"signals can be processed in the main loop of the program, otherwise "
"B<select>()  would block indefinitely."
msgstr ""
"***B<pselect>() est utile si vous attendez un signal ou qu'un/des "
"descripteur(s) de fichier deviennent prêts pour des entrées-sorties. Les "
"programmes qui reçoivent des signaux utilisent généralement le gestionnaire "
"de signal uniquement pour lever un drapeau global. Le drapeau global indique "
"que l'événement doit être traité dans la boucle principale du programme. Un "
"signal provoque l'arrêt de l'appel B<select>() (ou B<pselect>()) avec "
"I<errno> positionnée à B<EINTR>. Ce comportement est essentiel afin que les "
"signaux puissent être traités dans la boucle principale du programme, sinon "
"B<select>() bloquerait indéfiniment."

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-tumbleweed
msgid ""
"Now, somewhere in the main loop will be a conditional to check the global "
"flag.  So we must ask: what if a signal arrives after the conditional, but "
"before the B<select>()  call? The answer is that B<select>()  would block "
"indefinitely, even though an event is actually pending.  This race condition "
"is solved by the B<pselect>()  call.  This call can be used to set the "
"signal mask to a set of signals that are to be received only within the "
"B<pselect>()  call.  For instance, let us say that the event in question was "
"the exit of a child process.  Before the start of the main loop, we would "
"block B<SIGCHLD> using B<sigprocmask>(2).  Our B<pselect>()  call would "
"enable B<SIGCHLD> by using an empty signal mask.  Our program would look "
"like:"
msgstr ""
"Ceci étant, la boucle principale implante quelque part une condition "
"vérifiant le drapeau global, et l'on doit donc se demander\\ : que se passe-"
"t-il si un signal est levé après la condition mais avant l'appel à "
"B<select>()\\ ? La réponse est que B<select>() bloquerait indéfiniment, même "
"si un signal était en fait en attente. Cette \"race condition\" est résolue "
"par l'appel B<pselect>(). Cet appel peut être utilisé afin de définir le "
"masque des signaux qui sont censés n'être reçus que durant l'appel à "
"B<pselect>(). Par exemple, supposons que l'événement en question est la fin "
"d'un processus fils. Avant le démarrage de la boucle principale, nous "
"bloquerions B<SIGCHLD> en utilisant B<sigprocmask>(2). Notre appel "
"B<pselect>() débloquerait B<SIGCHLD> en utilisant le masque de signaux vide. "
"Le programme ressemblerait à ceci\\ :"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "static volatile sig_atomic_t got_SIGCHLD = 0;\n"
msgstr "static volatile sig_atomic_t got_SIGCHLD = 0;\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"static void\n"
"child_sig_handler(int sig)\n"
"{\n"
"    got_SIGCHLD = 1;\n"
"}\n"
msgstr ""
"static void\n"
"child_sig_handler(int sig)\n"
"{\n"
"    got_SIGCHLD = 1;\n"
"}\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t sigmask, empty_mask;\n"
"    struct sigaction sa;\n"
"    fd_set readfds, writefds, exceptfds;\n"
"    int r;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t sigmask, empty_mask;\n"
"    struct sigaction sa;\n"
"    fd_set readfds, writefds, exceptfds;\n"
"    int r;\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"    sigemptyset(&sigmask);\n"
"    sigaddset(&sigmask, SIGCHLD);\n"
"    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {\n"
"        perror(\"sigprocmask\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sigemptyset(&sigmask);\n"
"    sigaddset(&sigmask, SIGCHLD);\n"
"    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {\n"
"        perror(\"sigprocmask\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"    sa.sa_flags = 0;\n"
"    sa.sa_handler = child_sig_handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n"
"        perror(\"sigaction\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sa.sa_flags = 0;\n"
"    sa.sa_handler = child_sig_handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n"
"        perror(\"sigaction\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "    sigemptyset(&empty_mask);\n"
msgstr "    sigemptyset(&empty_mask);\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"    for (;;) {          /* main loop */\n"
"        /* Initialize readfds, writefds, and exceptfds\n"
"           before the pselect() call. (Code omitted.) */\n"
msgstr ""
"    for (;;) {          /* main loop */\n"
"        /* Initialiser readfds, writefds et exceptfds\n"
"           avant l'appel à pselect(). (Code omis.) */\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"        r = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    NULL, &empty_mask);\n"
"        if (r == -1 && errno != EINTR) {\n"
"            /* Handle error */\n"
"        }\n"
msgstr ""
"        r = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    NULL, &empty_mask);\n"
"        if (r == -1 && errno != EINTR) {\n"
"            /* Gérer les erreurs */\n"
"        }\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"        if (got_SIGCHLD) {\n"
"            got_SIGCHLD = 0;\n"
msgstr ""
"        if (got_SIGCHLD) {\n"
"            got_SIGCHLD = 0;\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"            /* Handle signalled event here; e.g., wait() for all\n"
"               terminated children. (Code omitted.) */\n"
"        }\n"
msgstr ""
"            /* Gérer les événements signalés ici; e.g., wait() pour\n"
"               que tous les fils se terminent. (Code omis.) */\n"
"        }\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"        /* main body of program */\n"
"    }\n"
"}\n"
msgstr ""
"        /* corps principal du programme */\n"
"    }\n"
"}\n"

#. type: SS
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "Practical"
msgstr "Pratique"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"So what is the point of B<select>()? Can't I just read and write to my file "
"descriptors whenever I want? The point of B<select>()  is that it watches "
"multiple descriptors at the same time and properly puts the process to sleep "
"if there is no activity.  UNIX programmers often find themselves in a "
"position where they have to handle I/O from more than one file descriptor "
"where the data flow may be intermittent.  If you were to merely create a "
"sequence of B<read>(2)  and B<write>(2)  calls, you would find that one of "
"your calls may block waiting for data from/to a file descriptor, while "
"another file descriptor is unused though ready for I/O.  B<select>()  "
"efficiently copes with this situation."
msgstr ""
"Quelle est donc la finalité de B<select>()\\ ? Ne peut on pas simplement "
"lire et écrire dans les descripteurs chaque fois qu'on le souhaite\\ ? "
"L'objet de B<select>() est de surveiller de multiples descripteurs "
"simultanément et d'endormir proprement le processus s'il n'y a pas "
"d'activité. Les programmeurs UNIX se retrouvent souvent dans une situation "
"dans laquelle ils doivent gérer des entrées-sorties provenant de plus d'un "
"descripteur de fichier et dans laquelle le flux de données est intermittent. "
"Si vous deviez créer une séquence d'appels B<read>(2) et B<write>(2), vous "
"vous retrouveriez potentiellement bloqué sur un de vos appels attendant pour "
"lire ou écrire des données à partir/vers un descripteur de fichier, alors "
"qu'un autre descripteur de fichier est inutilisé bien qu'il soit prêt pour "
"des entrées-sorties. B<select>() gère efficacement cette situation."

#. type: SS
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "Select law"
msgstr "Règles de select"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"Many people who try to use B<select>()  come across behavior that is "
"difficult to understand and produces nonportable or borderline results.  For "
"instance, the above program is carefully written not to block at any point, "
"even though it does not set its file descriptors to nonblocking mode.  It is "
"easy to introduce subtle errors that will remove the advantage of using "
"B<select>(), so here is a list of essentials to watch for when using "
"B<select>()."
msgstr ""
"De nombreuses personnes qui essaient d'utiliser B<select>() obtiennent un "
"comportement difficile à comprendre et produisent des résultats non "
"portables ou des effets de bord. Par exemple, le programme ci-dessus est "
"écrit avec précaution afin de ne bloquer nulle part, même s'il ne positionne "
"pas ses descripteurs de fichier en mode non bloquant.Il est facile "
"d'introduire des erreurs subtiles qui annuleraient l'avantage de "
"l'utilisation de B<select>(), aussi, voici une liste de points essentiels à "
"contrôler lors de l'utilisation de B<select>()."

#. type: TP
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"You should always try to use B<select>()  without a timeout.  Your program "
"should have nothing to do if there is no data available.  Code that depends "
"on timeouts is not usually portable and is difficult to debug."
msgstr ""
"Vous devriez toujours essayer d'utiliser B<select>() sans timeout. Votre "
"programme ne devrait rien avoir à faire s'il n'y a pas de données "
"disponibles. Le code dépendant de timeouts n'est en général pas portable et "
"difficile à déboguer."

#. type: TP
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"The value I<nfds> must be properly calculated for efficiency as explained "
"above."
msgstr ""
"La valeur I<nfds> doit être calculée correctement pour des raisons "
"d'efficacité comme expliqué plus haut."

#. type: TP
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"No file descriptor must be added to any set if you do not intend to check "
"its result after the B<select>()  call, and respond appropriately.  See next "
"rule."
msgstr ""
"Aucun descripteur de fichier ne doit être ajouté à un quelconque ensemble si "
"vous ne projetez pas de vérifier son état après un appel à B<select>(), et "
"de réagir de façon adéquate. Voir la règle suivante."

#. type: TP
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"After B<select>()  returns, all file descriptors in all sets should be "
"checked to see if they are ready."
msgstr ""
"Après le retour de B<select>(), tous les descripteurs de fichier dans tous "
"les ensembles devraient être testés pour savoir s'ils sont prêts."

#. type: TP
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "5."
msgstr "5."

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"The functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  do I<not> "
"necessarily read/write the full amount of data that you have requested.  If "
"they do read/write the full amount, it's because you have a low traffic load "
"and a fast stream.  This is not always going to be the case.  You should "
"cope with the case of your functions managing to send or receive only a "
"single byte."
msgstr ""
"Les fonctions B<read>(2), B<recv>(2), B<write>(2) et B<send>(2) ne lisent ou "
"n'écrivent I<pas> forcément la quantité totale de données spécifiée. Si "
"elles lisent/écrivent la quantité totale, c'est parce que vous avez une "
"faible charge de trafic et un flux rapide. Ce n'est pas toujours le cas. "
"Vous devriez gérer le cas où vos fonctions traitent seulement l'envoi ou la "
"réception d'un unique octet."

#. type: TP
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "6."
msgstr "6."

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"Never read/write only in single bytes at a time unless you are really sure "
"that you have a small amount of data to process.  It is extremely "
"inefficient not to read/write as much data as you can buffer each time.  The "
"buffers in the example below are 1024 bytes although they could easily be "
"made larger."
msgstr ""
"Ne lisez/n'écrivez jamais seulement quelques octets à la fois à moins que "
"vous ne soyez absolument sûr de n'avoir qu'une faible quantité de données à "
"traiter. Il est parfaitement inefficace de ne pas lire/écrire autant de "
"données que vous pouvez en stocker à chaque fois. Les tampons de l'exemple "
"ci-dessous font 1024 octets bien qu'ils aient facilement pu être rendus plus "
"grands."

#. type: TP
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "7."
msgstr "7."

#.  Nonetheless, you should still cope with these errors for completeness.
#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"Calls to B<read>(2), B<recv>(2), B<write>(2), B<send>(2), and B<select>()  "
"can fail with the error B<EINTR>, and calls to B<read>(2), B<recv>(2)  "
"B<write>(2), and B<send>(2)  can fail with I<errno> set to B<EAGAIN> "
"(B<EWOULDBLOCK>).  These results must be properly managed (not done properly "
"above).  If your program is not going to receive any signals, then it is "
"unlikely you will get B<EINTR>.  If your program does not set nonblocking I/"
"O, you will not get B<EAGAIN>."
msgstr ""
"Les appels à B<read>(2), B<recv>(2), B<write>(2), B<send>(2) et B<select>() "
"peuvent échouer avec l'erreur B<EINTR> et les appels à B<read>(2), "
"B<recv>(2), B<write>(2), B<write>(2) et B<send>(2) peuvent échouer avec "
"I<errno> positionné sur B<EAGAIN> (B<EWOULDBLOCK>). Ces résultats doivent "
"être correctement gérés (cela n'est pas fait correctement ci-dessus). Si "
"votre programme n'est pas censé recevoir de signal, alors, il est hautement "
"improbable que vous obteniez B<EINTR>. Si votre programme n'a pas configuré "
"les entrées-sorties en mode non bloquant, vous n'obtiendrez pas de B<EAGAIN>."

#. type: TP
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "8."
msgstr "8."

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"Never call B<read>(2), B<recv>(2), B<write>(2), or B<send>(2)  with a buffer "
"length of zero."
msgstr ""
"N'appelez jamais B<read>(2), B<recv>(2), B<write>(2) ou B<send>(2) avec un "
"tampon de taille nulle."

#. type: TP
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "9."
msgstr "9."

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"If the functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  fail "
"with errors other than those listed in B<7.>, or one of the input functions "
"returns 0, indicating end of file, then you should I<not> pass that file "
"descriptor to B<select>()  again.  In the example below, I close the file "
"descriptor immediately, and then set it to -1 to prevent it being included "
"in a set."
msgstr ""
"Si les fonctions B<read>(2), B<recv>(2), B<write>(2) et B<send>(2) échouent "
"avec une erreur autre que celles indiquées en B<7.>, ou si l'une des "
"fonctions d'entrée renvoie B<0>, indiquant une fin de fichier, vous I<ne> "
"devriez I<pas> utiliser ce descripteur à nouveau pour un appel à "
"B<select>(). Dans l'exemple ci-dessous, le descripteur est immédiatement "
"fermé et ensuite est positionné à B<-1> afin qu'il ne soit pas inclus dans "
"un ensemble."

#. type: TP
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "10."
msgstr "10."

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"The timeout value must be initialized with each new call to B<select>(), "
"since some operating systems modify the structure.  B<pselect>()  however "
"does not modify its timeout structure."
msgstr ""
"La valeur de timeout doit être initialisée à chaque nouvel appel à "
"B<select>(), puisque des systèmes d'exploitation modifient la structure. "
"Cependant, B<pselect>() ne modifie pas sa structure de timeout."

#. type: TP
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "11."
msgstr "11."

#.  "I have heard" does not fill me with confidence, and doesn't
#.  belong in a man page, so I've commented this point out.
#.  .TP
#.  11.
#.  I have heard that the Windows socket layer does not cope with OOB data
#.  properly.
#.  It also does not cope with
#.  .BR select ()
#.  calls when no file descriptors are set at all.
#.  Having no file descriptors set is a useful
#.  way to sleep the process with subsecond precision by using the timeout.
#.  (See further on.)
#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"Since B<select>()  modifies its file descriptor sets, if the call is being "
"used in a loop, then the sets must be reinitialized before each call."
msgstr ""
"Comme B<select>() modifie ses ensembles de descripteurs de fichiers, si "
"l'appel est effectué dans une boucle alors les ensembles doivent être "
"réinitialisés avant chaque appel."

#. type: SH
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "RETURN VALUE"
msgstr "VALEUR RENVOYÉE"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-tumbleweed
msgid "See B<select>(2)."
msgstr "Voir B<select>(2)."

#. type: SH
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "NOTES"
msgstr "NOTES"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"Generally speaking, all operating systems that support sockets also support "
"B<select>().  B<select>()  can be used to solve many problems in a portable "
"and efficient way that naive programmers try to solve in a more complicated "
"manner using threads, forking, IPCs, signals, memory sharing, and so on."
msgstr ""
"De façon générale, tous les systèmes d'exploitation qui gèrent les sockets "
"proposent également B<select>(). B<select>() peut être utilisé pour résoudre "
"de façon portable et efficace de nombreux problèmes que des programmeurs "
"naïfs essaient de résoudre avec des threads, des forks, des IPC, des "
"signaux, des mémoires partagées et d'autres méthodes peu élégantes."

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"The B<poll>(2)  system call has the same functionality as B<select>(), and "
"is somewhat more efficient when monitoring sparse file descriptor sets.  It "
"is nowadays widely available, but historically was less portable than "
"B<select>()."
msgstr ""
"L'appel système B<poll>(2) a les mêmes fonctionnalités que B<select>(), tout "
"en étant légèrement plus efficace quand il doit surveiller des ensembles de "
"descripteurs creux. Il est disponible sur la plupart des systèmes de nos "
"jours, mais était historiquement moins portable que B<select>()."

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"The Linux-specific B<epoll>(7)  API provides an interface that is more "
"efficient than B<select>(2)  and B<poll>(2)  when monitoring large numbers "
"of file descriptors."
msgstr ""
"L'API B<epoll>(7) spécifique à Linux fournit une interface plus efficace que "
"B<select>(2) et B<poll>(2) lorsque l'on surveille un grand nombre de "
"descripteurs de fichier."

#. type: SH
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-tumbleweed
#, no-wrap
msgid "EXAMPLES"
msgstr "EXEMPLES"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"Here is an example that better demonstrates the true utility of "
"B<select>().  The listing below is a TCP forwarding program that forwards "
"from one TCP port to another."
msgstr ""
"Voici un exemple qui montre mieux l'utilité réelle de B<select>(). Le code "
"ci-dessous consiste en un programme de «\\ TCP forwarding\\ » qui redirige "
"un port TCP vers un autre."

#. type: Plain text
#: archlinux debian-unstable fedora-rawhide mageia-cauldron
#, fuzzy, no-wrap
#| msgid ""
#| "#include E<lt>stdlib.hE<gt>\n"
#| "#include E<lt>stdio.hE<gt>\n"
#| "#include E<lt>unistd.hE<gt>\n"
#| "#include E<lt>sys/select.hE<gt>\n"
#| "#include E<lt>string.hE<gt>\n"
#| "#include E<lt>signal.hE<gt>\n"
#| "#include E<lt>sys/socket.hE<gt>\n"
#| "#include E<lt>netinet/in.hE<gt>\n"
#| "#include E<lt>arpa/inet.hE<gt>\n"
#| "#include E<lt>errno.hE<gt>\n"
msgid ""
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/select.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/select.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "static int forward_port;\n"
msgstr "static int forward_port;\n"

#. type: Plain text
#: archlinux debian-unstable fedora-rawhide mageia-cauldron
#, fuzzy, no-wrap
#| msgid ""
#| "#undef max\n"
#| "#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"
msgid ""
"#undef max\n"
"#define max(x, y) ((x) E<gt> (y) ? (x) : (y))\n"
msgstr ""
"#undef max\n"
"#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"

#. type: Plain text
#: archlinux debian-unstable fedora-rawhide mageia-cauldron
#, fuzzy, no-wrap
#| msgid ""
#| "static int\n"
#| "listen_socket(int listen_port)\n"
#| "{\n"
#| "    struct sockaddr_in addr;\n"
#| "    int lfd;\n"
#| "    int yes;\n"
msgid ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    int                 lfd;\n"
"    int                 yes;\n"
"    struct sockaddr_in  addr;\n"
msgstr ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int lfd;\n"
"    int yes;\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"    lfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (lfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    lfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (lfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: archlinux debian-unstable fedora-rawhide mageia-cauldron
#, fuzzy, no-wrap
#| msgid ""
#| "    yes = 1;\n"
#| "    if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR,\n"
#| "            &yes, sizeof(yes)) == -1) {\n"
#| "        perror(\"setsockopt\");\n"
#| "        close(lfd);\n"
#| "        return -1;\n"
#| "    }\n"
msgid ""
"    yes = 1;\n"
"    if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR,\n"
"                   &yes, sizeof(yes)) == -1)\n"
"    {\n"
"        perror(\"setsockopt\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    yes = 1;\n"
"    if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR,\n"
"            &yes, sizeof(yes)) == -1) {\n"
"        perror(\"setsockopt\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(listen_port);\n"
"    addr.sin_family = AF_INET;\n"
"    if (bind(lfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(listen_port);\n"
"    addr.sin_family = AF_INET;\n"
"    if (bind(lfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"bind\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"    printf(\"accepting connections on port %d\\en\", listen_port);\n"
"    listen(lfd, 10);\n"
"    return lfd;\n"
"}\n"
msgstr ""
"    printf(\"on accepte les connexions sur le port %d\\en\", listen_port);\n"
"    listen(lfd, 10);\n"
"    return lfd;\n"
"}\n"

#. type: Plain text
#: archlinux debian-unstable fedora-rawhide mageia-cauldron
#, fuzzy, no-wrap
#| msgid ""
#| "static int\n"
#| "connect_socket(int connect_port, char *address)\n"
#| "{\n"
#| "    struct sockaddr_in addr;\n"
#| "    int cfd;\n"
msgid ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    int                 cfd;\n"
"    struct sockaddr_in  addr;\n"
msgstr ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int cfd;\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"    cfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (cfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    cfd = socket(AF_INET, SOCK_STREAM, 0);\n"
"    if (cfd == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(connect_port);\n"
"    addr.sin_family = AF_INET;\n"
msgstr ""
"    memset(&addr, 0, sizeof(addr));\n"
"    addr.sin_port = htons(connect_port);\n"
"    addr.sin_family = AF_INET;\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-tumbleweed
#, no-wrap
msgid ""
"    if (!inet_aton(address, (struct in_addr *) &addr.sin_addr.s_addr)) {\n"
"        fprintf(stderr, \"inet_aton(): bad IP address format\\en\");\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    if (!inet_aton(address, (struct in_addr *) &addr.sin_addr.s_addr)) {\n"
"        fprintf(stderr, \"inet_aton() : mauvais format d'adresse IP\\en\");\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"    if (connect(cfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"connect()\");\n"
"        shutdown(cfd, SHUT_RDWR);\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"
"    return cfd;\n"
"}\n"
msgstr ""
"    if (connect(cfd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {\n"
"        perror(\"connect()\");\n"
"        shutdown(cfd, SHUT_RDWR);\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"
"    return cfd;\n"
"}\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"#define SHUT_FD1 do {                                \\e\n"
"                     if (fd1 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd1, SHUT_RDWR);   \\e\n"
"                         close(fd1);                 \\e\n"
"                         fd1 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""
"#define SHUT_FD1 do {                                \\e\n"
"                     if (fd1 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd1, SHUT_RDWR);   \\e\n"
"                         close(fd1);                 \\e\n"
"                         fd1 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"#define SHUT_FD2 do {                                \\e\n"
"                     if (fd2 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd2, SHUT_RDWR);   \\e\n"
"                         close(fd2);                 \\e\n"
"                         fd2 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""
"#define SHUT_FD2 do {                                \\e\n"
"                     if (fd2 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd2, SHUT_RDWR);   \\e\n"
"                         close(fd2);                 \\e\n"
"                         fd2 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "#define BUF_SIZE 1024\n"
msgstr "#define BUF_SIZE 1024\n"

#. type: Plain text
#: archlinux debian-unstable fedora-rawhide mageia-cauldron
#, fuzzy, no-wrap
#| msgid ""
#| "int\n"
#| "main(int argc, char *argv[])\n"
#| "{\n"
#| "    int h;\n"
#| "    int fd1 = -1, fd2 = -1;\n"
#| "    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
#| "    int buf1_avail = 0, buf1_written = 0;\n"
#| "    int buf2_avail = 0, buf2_written = 0;\n"
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int      h;\n"
"    int      ready, nfds;\n"
"    int      fd1 = -1, fd2 = -1;\n"
"    int      buf1_avail = 0, buf1_written = 0;\n"
"    int      buf2_avail = 0, buf2_written = 0;\n"
"    char     buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    fd_set   readfds, writefds, exceptfds;\n"
"    ssize_t  nbytes;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int h;\n"
"    int fd1 = -1, fd2 = -1;\n"
"    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    int buf1_avail = 0, buf1_written = 0;\n"
"    int buf2_avail = 0, buf2_written = 0;\n"

#. type: Plain text
#: archlinux debian-unstable fedora-rawhide mageia-cauldron
#, fuzzy, no-wrap
#| msgid ""
#| "    if (argc != 4) {\n"
#| "        fprintf(stderr, \"Usage\\en\\etfwd E<lt>listen-portE<gt> \"\n"
#| "                 \"E<lt>forward-to-portE<gt> E<lt>forward-to-ip-addressE<gt>\\en\");\n"
#| "        exit(EXIT_FAILURE);\n"
#| "    }\n"
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage\\en\\etfwd E<lt>listen-portE<gt> \"\n"
"                \"E<lt>forward-to-portE<gt> E<lt>forward-to-ip-addressE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Utilisation\\en\\etfwd E<lt>listen-portE<gt> \"\n"
"                 \"E<lt>forward-to-portE<gt> E<lt>forward-to-ip-addressE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "    signal(SIGPIPE, SIG_IGN);\n"
msgstr "    signal(SIGPIPE, SIG_IGN);\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "    forward_port = atoi(argv[2]);\n"
msgstr "    forward_port = atoi(argv[2]);\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"    h = listen_socket(atoi(argv[1]));\n"
"    if (h == -1)\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""
"    h = listen_socket(atoi(argv[1]));\n"
"    if (h == -1)\n"
"        exit(EXIT_FAILURE);\n"

#. type: Plain text
#: archlinux debian-unstable fedora-rawhide mageia-cauldron
#, fuzzy, no-wrap
#| msgid "    for (;;) {\n"
msgid ""
"    for (;;) {\n"
"        nfds = 0;\n"
msgstr "    for (;;) {\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"        FD_ZERO(&readfds);\n"
"        FD_ZERO(&writefds);\n"
"        FD_ZERO(&exceptfds);\n"
"        FD_SET(h, &readfds);\n"
"        nfds = max(nfds, h);\n"
msgstr ""
"        FD_ZERO(&readfds);\n"
"        FD_ZERO(&writefds);\n"
"        FD_ZERO(&exceptfds);\n"
"        FD_SET(h, &readfds);\n"
"        nfds = max(nfds, h);\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd1, &readfds);\n"
"            /* Note: nfds is updated below, when fd1 is added to\n"
"               exceptfds. */\n"
"        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd2, &readfds);\n"
msgstr ""
"        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd1, &readfds);\n"
"            /* Note: nfds est mis à jour ci-dessous, lorsque fd1\n"
"              est ajouté à exceptfds. */\n"
"        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE)\n"
"            FD_SET(fd2, &readfds);\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0)\n"
"            FD_SET(fd1, &writefds);\n"
"        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0)\n"
"            FD_SET(fd2, &writefds);\n"
msgstr ""
"        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0)\n"
"            FD_SET(fd1, &writefds);\n"
"        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0)\n"
"            FD_SET(fd2, &writefds);\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0) {\n"
"            FD_SET(fd1, &exceptfds);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0) {\n"
"            FD_SET(fd2, &exceptfds);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
msgstr ""
"        if (fd1 E<gt> 0) {\n"
"            FD_SET(fd1, &exceptfds);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0) {\n"
"            FD_SET(fd2, &exceptfds);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "        ready = select(nfds + 1, &readfds, &writefds, &exceptfds, NULL);\n"
msgstr "        ready = select(nfds + 1, &readfds, &writefds, &exceptfds, NULL);\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"        if (ready == -1 && errno == EINTR)\n"
"            continue;\n"
msgstr ""
"        if (ready == -1 && errno == EINTR)\n"
"            continue;\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"        if (ready == -1) {\n"
"            perror(\"select()\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        if (ready == -1) {\n"
"            perror(\"select()\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"        if (FD_ISSET(h, &readfds)) {\n"
"            socklen_t addrlen;\n"
"            struct sockaddr_in client_addr;\n"
"            int fd;\n"
msgstr ""
"        if (FD_ISSET(h, &readfds)) {\n"
"            socklen_t addrlen;\n"
"            struct sockaddr_in client_addr;\n"
"            int fd;\n"

#. type: Plain text
#: archlinux debian-unstable fedora-rawhide mageia-cauldron
#, fuzzy, no-wrap
#| msgid ""
#| "            addrlen = sizeof(client_addr);\n"
#| "            memset(&client_addr, 0, addrlen);\n"
#| "            fd = accept(h, (struct sockaddr *) &client_addr, &addrlen);\n"
#| "            if (fd == -1) {\n"
#| "                perror(\"accept()\");\n"
#| "            } else {\n"
#| "                SHUT_FD1;\n"
#| "                SHUT_FD2;\n"
#| "                buf1_avail = buf1_written = 0;\n"
#| "                buf2_avail = buf2_written = 0;\n"
#| "                fd1 = fd;\n"
#| "                fd2 = connect_socket(forward_port, argv[3]);\n"
#| "                if (fd2 == -1)\n"
#| "                    SHUT_FD1;\n"
#| "                else\n"
#| "                    printf(\"connect from %s\\en\",\n"
#| "                            inet_ntoa(client_addr.sin_addr));\n"
msgid ""
"            addrlen = sizeof(client_addr);\n"
"            memset(&client_addr, 0, addrlen);\n"
"            fd = accept(h, (struct sockaddr *) &client_addr, &addrlen);\n"
"            if (fd == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = fd;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connect from %s\\en\",\n"
"                           inet_ntoa(client_addr.sin_addr));\n"
msgstr ""
"            addrlen = sizeof(client_addr);\n"
"            memset(&client_addr, 0, addrlen);\n"
"            fd = accept(h, (struct sockaddr *) &client_addr, &addrlen);\n"
"            if (fd == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = fd;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connexion depuis %s\\en\",\n"
"                            inet_ntoa(client_addr.sin_addr));\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-tumbleweed
#, no-wrap
msgid ""
"                /* Skip any events on the old, closed file\n"
"                   descriptors. */\n"
msgstr ""
"                /* Passer les événements des anciens descripteurs de\n"
"                   fichier fermés. */\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-tumbleweed
#, no-wrap
msgid ""
"                continue;\n"
"            }\n"
"        }\n"
msgstr ""
"                continue;\n"
"            }\n"
"        }\n"

#. type: Plain text
#: archlinux debian-unstable fedora-37 fedora-rawhide mageia-cauldron
#: opensuse-tumbleweed
#, no-wrap
msgid "        /* NB: read OOB data before normal reads. */\n"
msgstr "        /* NB : lecture des données hors bande avant les lectures normales */\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &exceptfds)) {\n"
"            char c;\n"
msgstr ""
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &exceptfds)) {\n"
"            char c;\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"            nbytes = recv(fd1, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                send(fd2, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &exceptfds)) {\n"
"            char c;\n"
msgstr ""
"            nbytes = recv(fd1, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                send(fd2, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &exceptfds)) {\n"
"            char c;\n"

#. type: Plain text
#: archlinux debian-unstable fedora-rawhide mageia-cauldron
#, fuzzy, no-wrap
#| msgid ""
#| "            nbytes = recv(fd2, &c, 1, MSG_OOB);\n"
#| "            if (nbytes E<lt> 1)\n"
#| "                SHUT_FD2;\n"
#| "            else\n"
#| "                send(fd1, &c, 1, MSG_OOB);\n"
#| "        }\n"
#| "        if (fd1 E<gt> 0 && FD_ISSET(fd1, &readfds)) {\n"
#| "            nbytes = read(fd1, buf1 + buf1_avail,\n"
#| "                      BUF_SIZE - buf1_avail);\n"
#| "            if (nbytes E<lt> 1)\n"
#| "                SHUT_FD1;\n"
#| "            else\n"
#| "                buf1_avail += nbytes;\n"
#| "        }\n"
#| "        if (fd2 E<gt> 0 && FD_ISSET(fd2, &readfds)) {\n"
#| "            nbytes = read(fd2, buf2 + buf2_avail,\n"
#| "                      BUF_SIZE - buf2_avail);\n"
#| "            if (nbytes E<lt> 1)\n"
#| "                SHUT_FD2;\n"
#| "            else\n"
#| "                buf2_avail += nbytes;\n"
#| "        }\n"
#| "        if (fd1 E<gt> 0 && FD_ISSET(fd1, &writefds) && buf2_avail E<gt> 0) {\n"
#| "            nbytes = write(fd1, buf2 + buf2_written,\n"
#| "                       buf2_avail - buf2_written);\n"
#| "            if (nbytes E<lt> 1)\n"
#| "                SHUT_FD1;\n"
#| "            else\n"
#| "                buf2_written += nbytes;\n"
#| "        }\n"
#| "        if (fd2 E<gt> 0 && FD_ISSET(fd2, &writefds) && buf1_avail E<gt> 0) {\n"
#| "            nbytes = write(fd2, buf1 + buf1_written,\n"
#| "                       buf1_avail - buf1_written);\n"
#| "            if (nbytes E<lt> 1)\n"
#| "                SHUT_FD2;\n"
#| "            else\n"
#| "                buf1_written += nbytes;\n"
#| "        }\n"
msgid ""
"            nbytes = recv(fd2, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                send(fd1, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &readfds)) {\n"
"            nbytes = read(fd1, buf1 + buf1_avail,\n"
"                          BUF_SIZE - buf1_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf1_avail += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &readfds)) {\n"
"            nbytes = read(fd2, buf2 + buf2_avail,\n"
"                          BUF_SIZE - buf2_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf2_avail += nbytes;\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &writefds) && buf2_avail E<gt> 0) {\n"
"            nbytes = write(fd1, buf2 + buf2_written,\n"
"                           buf2_avail - buf2_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf2_written += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &writefds) && buf1_avail E<gt> 0) {\n"
"            nbytes = write(fd2, buf1 + buf1_written,\n"
"                           buf1_avail - buf1_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf1_written += nbytes;\n"
"        }\n"
msgstr ""
"            nbytes = recv(fd2, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                send(fd1, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &readfds)) {\n"
"            nbytes = read(fd1, buf1 + buf1_avail,\n"
"                      BUF_SIZE - buf1_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf1_avail += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &readfds)) {\n"
"            nbytes = read(fd2, buf2 + buf2_avail,\n"
"                      BUF_SIZE - buf2_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf2_avail += nbytes;\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &writefds) && buf2_avail E<gt> 0) {\n"
"            nbytes = write(fd1, buf2 + buf2_written,\n"
"                       buf2_avail - buf2_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf2_written += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &writefds) && buf1_avail E<gt> 0) {\n"
"            nbytes = write(fd2, buf1 + buf1_written,\n"
"                       buf1_avail - buf1_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf1_written += nbytes;\n"
"        }\n"

#. type: Plain text
#: archlinux debian-unstable fedora-37 fedora-rawhide mageia-cauldron
#: opensuse-tumbleweed
#, no-wrap
msgid "        /* Check if write data has caught read data. */\n"
msgstr "        /* Vérifier si l'écriture de données a rattrapé la lecture de données */\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"        if (buf1_written == buf1_avail)\n"
"            buf1_written = buf1_avail = 0;\n"
"        if (buf2_written == buf2_avail)\n"
"            buf2_written = buf2_avail = 0;\n"
msgstr ""
"        if (buf1_written == buf1_avail)\n"
"            buf1_written = buf1_avail = 0;\n"
"        if (buf2_written == buf2_avail)\n"
"            buf2_written = buf2_avail = 0;\n"

#. type: Plain text
#: archlinux debian-unstable fedora-37 fedora-rawhide mageia-cauldron
#: opensuse-tumbleweed
#, no-wrap
msgid ""
"        /* One side has closed the connection, keep\n"
"           writing to the other side until empty. */\n"
msgstr ""
"        /* une extrémité a fermé la connexion, continue\n"
"           d'écrire vers l'autre extrémité jusqu'à ce\n"
"           que ce soit vide */\n"

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"        if (fd1 E<lt> 0 && buf1_avail - buf1_written == 0)\n"
"            SHUT_FD2;\n"
"        if (fd2 E<lt> 0 && buf2_avail - buf2_written == 0)\n"
"            SHUT_FD1;\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"        if (fd1 E<lt> 0 && buf1_avail - buf1_written == 0)\n"
"            SHUT_FD2;\n"
"        if (fd2 E<lt> 0 && buf2_avail - buf2_written == 0)\n"
"            SHUT_FD1;\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

# NOTE: timeouts => expirations ? (pas que ici)
#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"The above program properly forwards most kinds of TCP connections including "
"OOB signal data transmitted by B<telnet> servers.  It handles the tricky "
"problem of having data flow in both directions simultaneously.  You might "
"think it more efficient to use a B<fork>(2)  call and devote a thread to "
"each stream.  This becomes more tricky than you might suspect.  Another idea "
"is to set nonblocking I/O using B<fcntl>(2).  This also has its problems "
"because you end up using inefficient timeouts."
msgstr ""
"Le programme ci-dessus redirige correctement la plupart des types de "
"connexions TCP y compris les signaux de données hors bande OOB transmis par "
"les serveurs B<telnet>. Il gère le problème épineux des flux de données "
"bidirectionnels simultanés. Vous pourriez penser qu'il est plus efficace "
"d'utiliser un appel B<fork>(2) et de dédier une tâche à chaque flux. Cela "
"devient alors plus délicat que vous ne l'imaginez. Une autre idée est de "
"configurer les entrées-sorties comme non bloquantes en utilisant "
"B<fcntl>(2). Cela pose également problème puisque ça vous force à utiliser "
"des timeouts inefficaces."

#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
msgid ""
"The program does not handle more than one simultaneous connection at a time, "
"although it could easily be extended to do this with a linked list of "
"buffers\\(emone for each connection.  At the moment, new connections cause "
"the current connection to be dropped."
msgstr ""
"Le programme ne gère pas plus d'une connexion à la fois bien qu'il soit "
"aisément extensible à une telle fonctionnalité en utilisant une liste "
"chaînée de tampons \\(em un pour chaque connexion. Pour l'instant, de "
"nouvelles connexions provoquent l'abandon de la connexion courante."

#. type: SH
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "SEE ALSO"
msgstr "VOIR AUSSI"

#. #-#-#-#-#  archlinux: select_tut.2.pot (PACKAGE VERSION)  #-#-#-#-#
#. type: Plain text
#. #-#-#-#-#  debian-bullseye: select_tut.2.pot (PACKAGE VERSION)  #-#-#-#-#
#.  .SH AUTHORS
#.  This man page was written by Paul Sheer.
#. type: Plain text
#. #-#-#-#-#  debian-unstable: select_tut.2.pot (PACKAGE VERSION)  #-#-#-#-#
#. type: Plain text
#. #-#-#-#-#  fedora-37: select_tut.2.pot (PACKAGE VERSION)  #-#-#-#-#
#.  .SH AUTHORS
#.  This man page was written by Paul Sheer.
#. type: Plain text
#. #-#-#-#-#  fedora-rawhide: select_tut.2.pot (PACKAGE VERSION)  #-#-#-#-#
#. type: Plain text
#. #-#-#-#-#  mageia-cauldron: select_tut.2.pot (PACKAGE VERSION)  #-#-#-#-#
#. type: Plain text
#. #-#-#-#-#  opensuse-tumbleweed: select_tut.2.pot (PACKAGE VERSION)  #-#-#-#-#
#. type: Plain text
#: archlinux debian-bullseye debian-unstable fedora-37 fedora-rawhide
#: mageia-cauldron opensuse-tumbleweed
msgid ""
"B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), "
"B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), B<epoll>(7)"
msgstr ""
"B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), "
"B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), B<epoll>(7)"

#. type: TH
#: debian-bullseye
#, no-wrap
msgid "2020-04-11"
msgstr "11 avril 2020"

#. type: TH
#: debian-bullseye fedora-37 opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: debian-bullseye fedora-37 opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Manuel du programmeur Linux"

#. type: Plain text
#: debian-bullseye fedora-37 opensuse-tumbleweed
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/select.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/select.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: debian-bullseye fedora-37 opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"#undef max\n"
"#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"
msgstr ""
"#undef max\n"
"#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"

#. type: Plain text
#: debian-bullseye fedora-37 opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int lfd;\n"
"    int yes;\n"
msgstr ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int lfd;\n"
"    int yes;\n"

#. type: Plain text
#: debian-bullseye fedora-37 opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"    yes = 1;\n"
"    if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR,\n"
"            &yes, sizeof(yes)) == -1) {\n"
"        perror(\"setsockopt\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    yes = 1;\n"
"    if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR,\n"
"            &yes, sizeof(yes)) == -1) {\n"
"        perror(\"setsockopt\");\n"
"        close(lfd);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: debian-bullseye fedora-37 opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int cfd;\n"
msgstr ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    struct sockaddr_in addr;\n"
"    int cfd;\n"

#. type: Plain text
#: debian-bullseye fedora-37 opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int h;\n"
"    int fd1 = -1, fd2 = -1;\n"
"    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    int buf1_avail = 0, buf1_written = 0;\n"
"    int buf2_avail = 0, buf2_written = 0;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int h;\n"
"    int fd1 = -1, fd2 = -1;\n"
"    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    int buf1_avail = 0, buf1_written = 0;\n"
"    int buf2_avail = 0, buf2_written = 0;\n"

#. type: Plain text
#: debian-bullseye fedora-37 opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage\\en\\etfwd E<lt>listen-portE<gt> \"\n"
"                 \"E<lt>forward-to-portE<gt> E<lt>forward-to-ip-addressE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Utilisation\\en\\etfwd E<lt>listen-portE<gt> \"\n"
"                 \"E<lt>forward-to-portE<gt> E<lt>forward-to-ip-addressE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: debian-bullseye fedora-37 opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"    for (;;) {\n"
"        int ready, nfds = 0;\n"
"        ssize_t nbytes;\n"
"        fd_set readfds, writefds, exceptfds;\n"
msgstr ""
"    for (;;) {\n"
"        int ready, nfds = 0;\n"
"        ssize_t nbytes;\n"
"        fd_set readfds, writefds, exceptfds;\n"

#. type: Plain text
#: debian-bullseye fedora-37 opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"            addrlen = sizeof(client_addr);\n"
"            memset(&client_addr, 0, addrlen);\n"
"            fd = accept(h, (struct sockaddr *) &client_addr, &addrlen);\n"
"            if (fd == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = fd;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connect from %s\\en\",\n"
"                            inet_ntoa(client_addr.sin_addr));\n"
msgstr ""
"            addrlen = sizeof(client_addr);\n"
"            memset(&client_addr, 0, addrlen);\n"
"            fd = accept(h, (struct sockaddr *) &client_addr, &addrlen);\n"
"            if (fd == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = fd;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connexion depuis %s\\en\",\n"
"                            inet_ntoa(client_addr.sin_addr));\n"

#. type: Plain text
#: debian-bullseye opensuse-leap-15-5
#, no-wrap
msgid "        /* NB: read OOB data before normal reads */\n"
msgstr "        /* NB : lecture des données hors bande avant les lectures normales */\n"

#. type: Plain text
#: debian-bullseye fedora-37 opensuse-leap-15-5 opensuse-tumbleweed
#, no-wrap
msgid ""
"            nbytes = recv(fd2, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                send(fd1, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &readfds)) {\n"
"            nbytes = read(fd1, buf1 + buf1_avail,\n"
"                      BUF_SIZE - buf1_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf1_avail += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &readfds)) {\n"
"            nbytes = read(fd2, buf2 + buf2_avail,\n"
"                      BUF_SIZE - buf2_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf2_avail += nbytes;\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &writefds) && buf2_avail E<gt> 0) {\n"
"            nbytes = write(fd1, buf2 + buf2_written,\n"
"                       buf2_avail - buf2_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf2_written += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &writefds) && buf1_avail E<gt> 0) {\n"
"            nbytes = write(fd2, buf1 + buf1_written,\n"
"                       buf1_avail - buf1_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf1_written += nbytes;\n"
"        }\n"
msgstr ""
"            nbytes = recv(fd2, &c, 1, MSG_OOB);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                send(fd1, &c, 1, MSG_OOB);\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &readfds)) {\n"
"            nbytes = read(fd1, buf1 + buf1_avail,\n"
"                      BUF_SIZE - buf1_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf1_avail += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &readfds)) {\n"
"            nbytes = read(fd2, buf2 + buf2_avail,\n"
"                      BUF_SIZE - buf2_avail);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf2_avail += nbytes;\n"
"        }\n"
"        if (fd1 E<gt> 0 && FD_ISSET(fd1, &writefds) && buf2_avail E<gt> 0) {\n"
"            nbytes = write(fd1, buf2 + buf2_written,\n"
"                       buf2_avail - buf2_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD1;\n"
"            else\n"
"                buf2_written += nbytes;\n"
"        }\n"
"        if (fd2 E<gt> 0 && FD_ISSET(fd2, &writefds) && buf1_avail E<gt> 0) {\n"
"            nbytes = write(fd2, buf1 + buf1_written,\n"
"                       buf1_avail - buf1_written);\n"
"            if (nbytes E<lt> 1)\n"
"                SHUT_FD2;\n"
"            else\n"
"                buf1_written += nbytes;\n"
"        }\n"

#. type: Plain text
#: debian-bullseye opensuse-leap-15-5
#, no-wrap
msgid "        /* Check if write data has caught read data */\n"
msgstr "        /* Vérifier si l'écriture de données a rattrapé la lecture de données */\n"

#. type: Plain text
#: debian-bullseye opensuse-leap-15-5
#, no-wrap
msgid ""
"        /* One side has closed the connection, keep\n"
"           writing to the other side until empty */\n"
msgstr ""
"        /* une extrémité a fermé la connexion, continue\n"
"           d'écrire vers l'autre extrémité jusqu'à ce\n"
"           que ce soit vide */\n"

#. type: SH
#: debian-bullseye fedora-37 opensuse-leap-15-5
#, no-wrap
msgid "COLOPHON"
msgstr "COLOPHON"

#. type: Plain text
#: debian-bullseye
msgid ""
"This page is part of release 5.10 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr ""
"Cette page fait partie de la publication 5.10 du projet I<man-pages> Linux. "
"Une description du projet et des instructions pour signaler des anomalies et "
"la dernière version de cette page peuvent être trouvées à l'adresse \\"
"%https://www.kernel.org/doc/man-pages/."

#. type: TH
#: fedora-37 opensuse-tumbleweed
#, no-wrap
msgid "2021-03-22"
msgstr "22 mars 2021"

#. type: Plain text
#: fedora-37
msgid ""
"This page is part of release 5.13 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr ""
"Cette page fait partie de la publication 5.13 du projet I<man-pages> Linux. "
"Une description du projet et des instructions pour signaler des anomalies et "
"la dernière version de cette page peuvent être trouvées à l'adresse \\"
"%https://www.kernel.org/doc/man-pages/."

#. type: TH
#: opensuse-leap-15-5
#, no-wrap
msgid "2017-09-15"
msgstr "15 septembre 2017"

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O "
"multiplexing"
msgstr ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - Multiplexage d'entrées-"
"sorties synchrones"

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"/* According to POSIX.1-2001, POSIX.1-2008 */\n"
"B<#include E<lt>sys/select.hE<gt>>\n"
msgstr ""
"/* Selon POSIX.1-2001, POSIX.1-2008 */\n"
"B<#include E<lt>sys/select.hE<gt>>\n"

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"/* According to earlier standards */\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"/* Selon les anciens standards */\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<utimeout>B<);>\n"
msgstr ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<utimeout>B<);>\n"

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<void FD_ZERO(fd_set *>I<set>B<);>\n"
msgstr ""
"B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
"B<void FD_ZERO(fd_set *>I<set>B<);>\n"

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid "B<#include E<lt>sys/select.hE<gt>>\n"
msgstr "B<#include E<lt>sys/select.hE<gt>>\n"

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<ntimeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<ntimeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""
"Exigences de macros de test de fonctionnalités pour la glibc (consulter "
"B<feature_test_macros>(7)) :"

#. type: Plain text
#: opensuse-leap-15-5
msgid "B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"B<select>()  (or B<pselect>())  is used to efficiently monitor multiple file "
"descriptors, to see if any of them is, or becomes, \"ready\"; that is, to "
"see whether I/O becomes possible, or an \"exceptional condition\" has "
"occurred on any of the file descriptors."
msgstr ""
"B<select>() (ou B<pselect>()) est utilisé pour superviser efficacement "
"plusieurs descripteurs de fichiers pour vérifier si l'un d'entre eux est ou "
"devient « prêt » ; c'est-à-dire savoir si des entrées-sorties deviennent "
"possibles ou si une « condition exceptionnelle » est survenue sur l'un des "
"descripteurs."

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"Its principal arguments are three \"sets\" of file descriptors: I<readfds>, "
"I<writefds>, and I<exceptfds>.  Each set is declared as type I<fd_set>, and "
"its contents can be manipulated with the macros B<FD_CLR>(), B<FD_ISSET>(), "
"B<FD_SET>(), and B<FD_ZERO>().  A newly declared set should first be cleared "
"using B<FD_ZERO>().  B<select>()  modifies the contents of the sets "
"according to the rules described below; after calling B<select>()  you can "
"test if a file descriptor is still present in a set with the B<FD_ISSET>()  "
"macro.  B<FD_ISSET>()  returns nonzero if a specified file descriptor is "
"present in a set and zero if it is not.  B<FD_CLR>()  removes a file "
"descriptor from a set."
msgstr ""
"Ses paramètres principaux sont trois « ensembles » de descripteurs de "
"fichiers : I<readfds>, I<writefds> et I<exceptfds>. Chaque ensemble est de "
"type I<fd_set>, et son contenu peut être manipulé avec les macros "
"B<FD_CLR>(), B<FD_ISSET>(), B<FD_SET>(), et B<FD_ZERO>(). Un ensemble "
"nouvellement déclaré doit d'abord être effacé en utilisant B<FD_ZERO>(). "
"B<select>() modifie le contenu de ces ensembles selon les règles ci-dessous. "
"Après un appel à B<select>(), vous pouvez vérifier si un descripteur de "
"fichier est toujours présent dans l'ensemble à l'aide de la macro "
"B<FD_ISSET>(). B<FD_ISSET>() renvoie une valeur non nulle si un descripteur "
"de fichier indiqué est présent dans un ensemble et zéro s'il ne l'est pas. "
"B<FD_CLR>() retire un descripteur de fichier d'un ensemble."

#. type: SS
#: opensuse-leap-15-5
#, no-wrap
msgid "Arguments"
msgstr "Arguments"

#. type: TP
#: opensuse-leap-15-5
#, no-wrap
msgid "I<readfds>"
msgstr "I<readfds>"

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"This set is watched to see if data is available for reading from any of its "
"file descriptors.  After B<select>()  has returned, I<readfds> will be "
"cleared of all file descriptors except for those that are immediately "
"available for reading."
msgstr ""
"Cet ensemble est examiné afin de déterminer si des données sont disponibles "
"en lecture à partir d'un de ses descripteurs de fichier. Suite à un appel à "
"B<select>(), I<readfds> ne contient plus aucun de ses descripteurs de "
"fichiers à l'exception de ceux qui sont immédiatement disponibles pour une "
"lecture."

#. type: TP
#: opensuse-leap-15-5
#, no-wrap
msgid "I<writefds>"
msgstr "I<writefds>"

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"This set is watched to see if there is space to write data to any of its "
"file descriptors.  After B<select>()  has returned, I<writefds> will be "
"cleared of all file descriptors except for those that are immediately "
"available for writing."
msgstr ""
"Cet ensemble est examiné afin de déterminer s'il y a de l'espace afin "
"d'écrire des données dans un de ses descripteurs de fichier. Suite à un "
"appel à B<select>(), I<writefds> ne contient plus aucun de ses descripteurs "
"de fichiers à l'exception de ceux qui sont immédiatement disponibles pour "
"une écriture."

#. type: TP
#: opensuse-leap-15-5
#, no-wrap
msgid "I<exceptfds>"
msgstr "I<exceptfds>"

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"This set is watched for \"exceptional conditions\".  In practice, only one "
"such exceptional condition is common: the availability of I<out-of-band> "
"(OOB) data for reading from a TCP socket.  See B<recv>(2), B<send>(2), and "
"B<tcp>(7)  for more details about OOB data.  (One other less common case "
"where B<select>(2)  indicates an exceptional condition occurs with "
"pseudoterminals in packet mode; see B<ioctl_tty>(2).)  After B<select>()  "
"has returned, I<exceptfds> will be cleared of all file descriptors except "
"for those for which an exceptional condition has occurred."
msgstr ""
"Cet ensemble est examiné pour des « conditions exceptionnelles ». En "
"pratique, seule une condition exceptionnelle est courante : la disponibilité "
"de données I<hors-bande> (OOB : Out Of Band) en lecture sur un socket TCP. "
"Consultez B<recv>(2), B<send>(2) et B<tcp>(7) pour plus de détails sur les "
"données hors bande. Un autre cas moins courant dans lequel B<select>(2) "
"indique une condition exceptionnelle survient avec des pseudoterminaux en "
"mode paquet ; consultez B<tty_ioctl>(4).) Suite à un appel à B<select>(), "
"I<exceptfds> ne contient plus aucun de ses descripteurs de fichier à "
"l'exception de ceux pour lesquels une condition exceptionnelle est survenue."

#. type: TP
#: opensuse-leap-15-5
#, no-wrap
msgid "I<nfds>"
msgstr "I<nfds>"

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"This is an integer one more than the maximum of any file descriptor in any "
"of the sets.  In other words, while adding file descriptors to each of the "
"sets, you must calculate the maximum integer value of all of them, then "
"increment this value by one, and then pass this as I<nfds>."
msgstr ""
"Il s'agit d'un entier valant un de plus que n'importe lequel des "
"descripteurs de fichier de tous les ensembles. En d'autres termes, lorsque "
"vous ajoutez des descripteurs de fichier à chacun des ensembles, vous devez "
"déterminer la valeur entière maximale de tous ces derniers, puis ajouter un "
"à cette valeur, et la passer comme paramètre I<nfds>."

#. type: TP
#: opensuse-leap-15-5
#, no-wrap
msgid "I<utimeout>"
msgstr "I<utimeout>"

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"This is the longest time B<select>()  may wait before returning, even if "
"nothing interesting happened.  If this value is passed as NULL, then "
"B<select>()  blocks indefinitely waiting for a file descriptor to become "
"ready.  I<utimeout> can be set to zero seconds, which causes B<select>()  to "
"return immediately, with information about the readiness of file descriptors "
"at the time of the call.  The structure I<struct timeval> is defined as:"
msgstr ""
"Il s'agit du temps le plus long que B<select>() pourrait attendre avant de "
"rendre la main, même si rien d'intéressant n'est arrivé. Si cette valeur est "
"positionnée à NULL, alors, B<select>() bloque indéfiniment dans l'attente "
"qu'un descripteur de fichier devienne prêt. I<utimeout> peut être positionné "
"à zéro seconde, ce qui provoque le retour immédiat de B<select>(), en "
"indiquant quels descripteurs de fichiers étaient prêts au moment de l'appel. "
"La structure I<struct timeval> est définie comme :"

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long tv_usec;     /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    time_t tv_sec;    /* secondes */\n"
"    long tv_usec;     /* microsecondes */\n"
"};\n"

#. type: TP
#: opensuse-leap-15-5
#, no-wrap
msgid "I<ntimeout>"
msgstr "I<ntimeout>"

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"This argument for B<pselect>()  has the same meaning as I<utimeout>, but "
"I<struct timespec> has nanosecond precision as follows:"
msgstr ""
"Ce paramètre de B<pselect>() a la même signification que I<utimeout>, mais "
"I<struct timespec> a une précision à la nanoseconde comme explicité ci-"
"dessous\\ :"

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"struct timespec {\n"
"    long tv_sec;    /* seconds */\n"
"    long tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    long tv_sec;    /* secondes */\n"
"    long tv_nsec;   /* nanosecondes */\n"
"};\n"

#. type: TP
#: opensuse-leap-15-5
#, no-wrap
msgid "I<sigmask>"
msgstr "I<sigmask>"

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"This argument holds a set of signals that the kernel should unblock (i.e., "
"remove from the signal mask of the calling thread), while the caller is "
"blocked inside the B<pselect>()  call (see B<sigaddset>(3)  and "
"B<sigprocmask>(2)).  It may be NULL, in which case the call does not modify "
"the signal mask on entry and exit to the function.  In this case, "
"B<pselect>()  will then behave just like B<select>()."
msgstr ""
"Cet argument renferme un ensemble de signaux que le noyau doit débloquer "
"(c'est-à-dire supprimer du masque de signaux du thread appelant) pendant que "
"l'appelant est bloqué par B<pselect>() (consultez B<sigaddset>(3) et "
"B<sigprocmask>(2)). Il peut valoir NULL et, dans ce cas, il ne modifie pas "
"l'ensemble des signaux non bloqués à l'entrée et la sortie de la fonction. "
"Dans ce cas, B<pselect>() se comporte alors de façon identique à B<select>()."

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"B<pselect>()  is useful if you are waiting for a signal as well as for file "
"descriptor(s) to become ready for I/O.  Programs that receive signals "
"normally use the signal handler only to raise a global flag.  The global "
"flag will indicate that the event must be processed in the main loop of the "
"program.  A signal will cause the B<select>()  (or B<pselect>())  call to "
"return with I<errno> set to B<EINTR>.  This behavior is essential so that "
"signals can be processed in the main loop of the program, otherwise "
"B<select>()  would block indefinitely.  Now, somewhere in the main loop will "
"be a conditional to check the global flag.  So we must ask: what if a signal "
"arrives after the conditional, but before the B<select>()  call? The answer "
"is that B<select>()  would block indefinitely, even though an event is "
"actually pending.  This race condition is solved by the B<pselect>()  call.  "
"This call can be used to set the signal mask to a set of signals that are to "
"be received only within the B<pselect>()  call.  For instance, let us say "
"that the event in question was the exit of a child process.  Before the "
"start of the main loop, we would block B<SIGCHLD> using B<sigprocmask>(2).  "
"Our B<pselect>()  call would enable B<SIGCHLD> by using an empty signal "
"mask.  Our program would look like:"
msgstr ""
"B<pselect>() est utile si vous attendez un signal ou qu'un/des "
"descripteur(s) de fichier deviennent prêts pour des entrées-sorties. Les "
"programmes qui reçoivent des signaux utilisent généralement le gestionnaire "
"de signal uniquement pour lever un drapeau global. Le drapeau global indique "
"que l'événement doit être traité dans la boucle principale du programme. Un "
"signal provoque l'arrêt de l'appel B<select>() (ou B<pselect>()) avec "
"I<errno> positionnée à B<EINTR>. Ce comportement est essentiel afin que les "
"signaux puissent être traités dans la boucle principale du programme, sinon "
"B<select>() bloquerait indéfiniment. Ceci étant, la boucle principale "
"implante quelque part une condition vérifiant le drapeau global, et l'on "
"doit donc se demander\\ : que se passe-t-il si un signal est levé après la "
"condition mais avant l'appel à B<select>()\\ ? La réponse est que "
"B<select>() bloquerait indéfiniment, même si un signal est en fait en "
"attente. Cette \"race condition\" est résolue par l'appel B<pselect>(). Cet "
"appel peut être utilisé afin de définir le masque des signaux qui sont "
"censés être reçus que durant l'appel à B<pselect>(). Par exemple, disons que "
"l'événement en question est la fin d'un processus fils. Avant le démarrage "
"de la boucle principale, nous bloquerions B<SIGCHLD> en utilisant "
"B<sigprocmask>(2). Notre appel B<pselect>() débloquerait B<SIGCHLD> en "
"utilisant le masque de signaux vide. Le programme ressemblerait à ceci\\ :"

#. type: SS
#: opensuse-leap-15-5
#, no-wrap
msgid "Usleep emulation"
msgstr "Émulation de usleep"

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"On systems that do not have a B<usleep>(3)  function, you can call "
"B<select>()  with a finite timeout and no file descriptors as follows:"
msgstr ""
"Sur les systèmes qui ne possèdent pas la fonction B<usleep>(3), vous pouvez "
"appeler B<select>() avec un timeout à valeur finie et sans descripteur de "
"fichier de la façon suivante\\ :"

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"struct timeval tv;\n"
"tv.tv_sec = 0;\n"
"tv.tv_usec = 200000;  /* 0.2 seconds */\n"
"select(0, NULL, NULL, NULL, &tv);\n"
msgstr ""
"struct timeval tv;\n"
"tv.tv_sec = 0;\n"
"tv.tv_usec = 200000;  /* 0.2 seconds */\n"
"select(0, NULL, NULL, NULL, &tv);\n"

#. type: Plain text
#: opensuse-leap-15-5
msgid "This is guaranteed to work only on UNIX systems, however."
msgstr "Le fonctionnement n'est cependant garanti que sur les systèmes UNIX."

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"On success, B<select>()  returns the total number of file descriptors still "
"present in the file descriptor sets."
msgstr ""
"En cas de succès, B<select>() renvoie le nombre total de descripteurs de "
"fichiers encore présents dans les ensembles de descripteurs de fichier."

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"If B<select>()  timed out, then the return value will be zero.  The file "
"descriptors set should be all empty (but may not be on some systems)."
msgstr ""
"En cas de timeout échu, alors les descripteurs de fichier devraient tous "
"être vides (mais peuvent ne pas l'être sur certains systèmes). Par contre, "
"la valeur renvoyée est zéro."

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"A return value of -1 indicates an error, with I<errno> being set "
"appropriately.  In the case of an error, the contents of the returned sets "
"and the I<struct timeout> contents are undefined and should not be used.  "
"B<pselect>()  however never modifies I<ntimeout>."
msgstr ""
"Une valeur de retour égale à -1 indique une erreur, I<errno> est alors "
"positionné de façon adéquate. En cas d'erreur, le contenu des ensembles "
"renvoyés et le contenu de la structure de I<timeout> sont indéfinis et ne "
"devraient pas être exploités. B<pselect>() ne modifie cependant jamais "
"I<ntimeout>."

#. type: SH
#: opensuse-leap-15-5
#, no-wrap
msgid "EXAMPLE"
msgstr "EXEMPLE"

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"    if (!inet_aton(address, (struct in_addr *) &addr.sin_addr.s_addr)) {\n"
"        perror(\"bad IP address format\");\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    if (!inet_aton(address, (struct in_addr *) &addr.sin_addr.s_addr)) {\n"
"        perror(\"bad IP address format\");\n"
"        close(cfd);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"                /* Skip any events on the old, closed file descriptors. */\n"
"                continue;\n"
"            }\n"
"        }\n"
msgstr ""
"                /* Passer les événements des anciens descripteurs fermés. */\n"
"                continue;\n"
"            }\n"
"        }\n"

#.  .SH AUTHORS
#.  This man page was written by Paul Sheer.
#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"B<accept>(2), B<connect>(2), B<ioctl>(2), B<poll>(2), B<read>(2), "
"B<recv>(2), B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<sigaddset>(3), B<sigdelset>(3), B<sigemptyset>(3), B<sigfillset>(3), "
"B<sigismember>(3), B<epoll>(7)"
msgstr ""
"B<accept>(2), B<connect>(2), B<ioctl>(2), B<poll>(2), B<read>(2), "
"B<recv>(2), B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<sigaddset>(3), B<sigdelset>(3), B<sigemptyset>(3), B<sigfillset>(3), "
"B<sigismember>(3), B<epoll>(7)"

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"This page is part of release 4.16 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man-"
"pages/."
msgstr ""
"Cette page fait partie de la publication 4.16 du projet I<man-pages> Linux. "
"Une description du projet et des instructions pour signaler des anomalies et "
"la dernière version de cette page peuvent être trouvées à l'adresse \\"
"%https://www.kernel.org/doc/man-pages/."
