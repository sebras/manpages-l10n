# German translation of manpages
# This file is distributed under the same license as the manpages-de package.
# Copyright © of this file:
msgid ""
msgstr ""
"Project-Id-Version: manpages-de\n"
"POT-Creation-Date: 2018-02-24 22:00+0100\n"
"PO-Revision-Date: 2018-02-24 21:47+0100\n"
"Last-Translator: Automatically generated\n"
"Language-Team: German <debian-l10n-german@lists.debian.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#. type: TH
#, no-wrap
msgid "SYSTEMD\\&.UNIT"
msgstr ""

#. type: TH
#, no-wrap
msgid "systemd 236"
msgstr "systemd 236"

#. type: TH
#, no-wrap
msgid "systemd.unit"
msgstr ""

#.  -----------------------------------------------------------------
#.  * MAIN CONTENT STARTS HERE *
#.  -----------------------------------------------------------------
#. type: SH
#, no-wrap
msgid "NAME"
msgstr "BEZEICHNUNG"

#. type: Plain text
msgid "systemd.unit - Unit configuration"
msgstr ""

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr "ÜBERSICHT"

#. type: Plain text
msgid ""
"I<service>\\&.service, I<socket>\\&.socket, I<device>\\&.device, I<mount>\\&."
"mount, I<automount>\\&.automount, I<swap>\\&.swap, I<target>\\&.target, "
"I<path>\\&.path, I<timer>\\&.timer, I<slice>\\&.slice, I<scope>\\&.scope"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"/etc/systemd/system/*\n"
"/run/systemd/system/*\n"
"/lib/systemd/system/*\n"
"\\&...\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"~/\\&.config/systemd/user/*\n"
"/etc/systemd/user/*\n"
"$XDG_RUNTIME_DIR/systemd/user/*\n"
"/run/systemd/user/*\n"
"~/\\&.local/share/systemd/user/*\n"
"/usr/lib/systemd/user/*\n"
"\\&...\n"
msgstr ""

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr "BESCHREIBUNG"

#. type: Plain text
msgid ""
"A unit configuration file encodes information about a service, a socket, a "
"device, a mount point, an automount point, a swap file or partition, a start-"
"up target, a watched file system path, a timer controlled and supervised by "
"B<systemd>(1), a resource management slice or a group of externally created "
"processes\\&. The syntax is inspired by \\m[blue]B<XDG Desktop Entry "
"Specification>\\m[]\\&\\s-2\\u[1]\\d\\s+2 \\&.desktop files, which are in "
"turn inspired by Microsoft Windows \\&.ini files\\&."
msgstr ""

#. type: Plain text
msgid ""
"This man page lists the common configuration options of all the unit types"
"\\&. These options need to be configured in the [Unit] or [Install] sections "
"of the unit files\\&."
msgstr ""

#. type: Plain text
msgid ""
"In addition to the generic [Unit] and [Install] sections described here, "
"each unit may have a type-specific section, e\\&.g\\&. [Service] for a "
"service unit\\&. See the respective man pages for more information: "
"B<systemd.service>(5), B<systemd.socket>(5), B<systemd.device>(5), B<systemd."
"mount>(5), B<systemd.automount>(5), B<systemd.swap>(5), B<systemd."
"target>(5), B<systemd.path>(5), B<systemd.timer>(5), B<systemd.slice>(5), "
"B<systemd.scope>(5)\\&."
msgstr ""

#. type: Plain text
msgid ""
"Various settings are allowed to be specified more than once, in which case "
"the interpretation depends on the setting\\&. Often, multiple settings form "
"a list, and setting to an empty value \"resets\", which means that previous "
"assignments are ignored\\&. When this is allowed, it is mentioned in the "
"description of the setting\\&. Note that using multiple assignments to the "
"same value makes the unit file incompatible with parsers for the XDG \\&."
"desktop file format\\&."
msgstr ""

#. type: Plain text
msgid ""
"Unit files are loaded from a set of paths determined during compilation, "
"described in the next section\\&."
msgstr ""

#. type: Plain text
msgid ""
"Unit files may contain additional options on top of those listed here\\&. If "
"systemd encounters an unknown option, it will write a warning log message "
"but continue loading the unit\\&. If an option or section name is prefixed "
"with B<X->, it is ignored completely by systemd\\&. Options within an "
"ignored section do not need the prefix\\&. Applications may use this to "
"include additional information in the unit files\\&."
msgstr ""

#. type: Plain text
msgid ""
"Boolean arguments used in unit files can be written in various formats\\&. "
"For positive settings the strings B<1>, B<yes>, B<true> and B<on> are "
"equivalent\\&. For negative settings, the strings B<0>, B<no>, B<false> and "
"B<off> are equivalent\\&."
msgstr ""

#. type: Plain text
msgid ""
"Time span values encoded in unit files can be written in various formats\\&. "
"A stand-alone number specifies a time in seconds\\&. If suffixed with a time "
"unit, the unit is honored\\&. A concatenation of multiple values with units "
"is supported, in which case the values are added up\\&. Example: \"50\" "
"refers to 50 seconds; \"2min\\ \\&200ms\" refers to 2 minutes and 200 "
"milliseconds, i\\&.e\\&. 120200\\ \\&ms\\&. The following time units are "
"understood: \"s\", \"min\", \"h\", \"d\", \"w\", \"ms\", \"us\"\\&. For "
"details see B<systemd.time>(7)\\&."
msgstr ""

#. type: Plain text
msgid ""
"Empty lines and lines starting with \"#\" or \";\" are ignored\\&. This may "
"be used for commenting\\&. Lines ending in a backslash are concatenated with "
"the following line while reading and the backslash is replaced by a space "
"character\\&. This may be used to wrap long lines\\&."
msgstr ""

#. type: Plain text
msgid ""
"Units can be aliased (have an alternative name), by creating a symlink from "
"the new name to the existing name in one of the unit search paths\\&. For "
"example, systemd-networkd\\&.service has the alias dbus-org\\&.freedesktop"
"\\&.network1\\&.service, created during installation as the symlink /lib/"
"systemd/system/dbus-org\\&.freedesktop\\&.network1\\&.service\\&. In "
"addition, unit files may specify aliases through the I<Alias=> directive in "
"the [Install] section; those aliases are only effective when the unit is "
"enabled\\&. When the unit is enabled, symlinks will be created for those "
"names, and removed when the unit is disabled\\&. For example, reboot\\&."
"target specifies I<Alias=ctrl-alt-del\\&.target>, so when enabled it will be "
"invoked whenever CTRL+ALT+DEL is pressed\\&. Alias names may be used in "
"commands like B<enable>, B<disable>, B<start>, B<stop>, B<status>, \\&..., "
"and in unit dependency directives I<Wants=>, I<Requires=>, I<Before=>, "
"I<After=>, \\&..., with the limitation that aliases specified through "
"I<Alias=> are only effective when the unit is enabled\\&. Aliases cannot be "
"used with the B<preset> command\\&."
msgstr ""

#. type: Plain text
msgid ""
"Along with a unit file foo\\&.service, the directory foo\\&.service\\&."
"wants/ may exist\\&. All unit files symlinked from such a directory are "
"implicitly added as dependencies of type I<Wants=> to the unit\\&. This is "
"useful to hook units into the start-up of other units, without having to "
"modify their unit files\\&. For details about the semantics of I<Wants=>, "
"see below\\&. The preferred way to create symlinks in the \\&.wants/ "
"directory of a unit file is with the B<enable> command of the "
"B<systemctl>(1)  tool which reads information from the [Install] section of "
"unit files (see below)\\&. A similar functionality exists for I<Requires=> "
"type dependencies as well, the directory suffix is \\&.requires/ in this case"
"\\&."
msgstr ""

#. type: Plain text
msgid ""
"Along with a unit file foo\\&.service, a \"drop-in\" directory foo\\&.service"
"\\&.d/ may exist\\&. All files with the suffix \"\\&.conf\" from this "
"directory will be parsed after the file itself is parsed\\&. This is useful "
"to alter or add configuration settings for a unit, without having to modify "
"unit files\\&. Each drop-in file must have appropriate section headers\\&. "
"Note that for instantiated units, this logic will first look for the "
"instance \"\\&.d/\" subdirectory and read its \"\\&.conf\" files, followed "
"by the template \"\\&.d/\" subdirectory and the \"\\&.conf\" files there\\&."
msgstr ""

#. type: Plain text
msgid ""
"In addition to /etc/systemd/system, the drop-in \"\\&.d\" directories for "
"system services can be placed in /lib/systemd/system or /run/systemd/system "
"directories\\&. Drop-in files in /etc take precedence over those in /run "
"which in turn take precedence over those in /lib\\&. Drop-in files under any "
"of these directories take precedence over unit files wherever located\\&. "
"Multiple drop-in files with different names are applied in lexicographic "
"order, regardless of which of the directories they reside in\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that while systemd offers a flexible dependency system between units it "
"is recommended to use this functionality only sparingly and instead rely on "
"techniques such as bus-based or socket-based activation which make "
"dependencies implicit, resulting in a both simpler and more flexible system"
"\\&."
msgstr ""

#. type: Plain text
msgid ""
"Optionally, units may be instantiated from a template file at runtime\\&. "
"This allows creation of multiple units from a single configuration file\\&. "
"If systemd looks for a unit configuration file, it will first search for the "
"literal unit name in the file system\\&. If that yields no success and the "
"unit name contains an \"@\" character, systemd will look for a unit template "
"that shares the same name but with the instance string (i\\&.e\\&. the part "
"between the \"@\" character and the suffix) removed\\&. Example: if a "
"service getty@tty3\\&.service is requested and no file by that name is "
"found, systemd will look for getty@\\&.service and instantiate a service "
"from that configuration file if it is found\\&."
msgstr ""

#. type: Plain text
msgid ""
"To refer to the instance string from within the configuration file you may "
"use the special \"%i\" specifier in many of the configuration options\\&. "
"See below for details\\&."
msgstr ""

#. type: Plain text
msgid ""
"If a unit file is empty (i\\&.e\\&. has the file size 0) or is symlinked to /"
"dev/null, its configuration will not be loaded and it appears with a load "
"state of \"masked\", and cannot be activated\\&. Use this as an effective "
"way to fully disable a unit, making it impossible to start it even manually"
"\\&."
msgstr ""

#. type: Plain text
msgid ""
"The unit file format is covered by the \\m[blue]B<Interface Stability "
"Promise>\\m[]\\&\\s-2\\u[2]\\d\\s+2\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "STRING ESCAPING FOR INCLUSION IN UNIT NAMES"
msgstr ""

#. type: Plain text
msgid ""
"Sometimes it is useful to convert arbitrary strings into unit names\\&. To "
"facilitate this, a method of string escaping is used, in order to map "
"strings containing arbitrary byte values (except NUL) into valid unit names "
"and their restricted character set\\&. A common special case are unit names "
"that reflect paths to objects in the file system hierarchy\\&. Example: a "
"device unit dev-sda\\&.device refers to a device with the device node /dev/"
"sda in the file system\\&."
msgstr ""

#. type: Plain text
msgid ""
"The escaping algorithm operates as follows: given a string, any \"/\" "
"character is replaced by \"-\", and all other characters which are not ASCII "
"alphanumerics or \"_\" are replaced by C-style \"\\ex2d\" escapes\\&. In "
"addition, \"\\&.\" is replaced with such a C-style escape when it would "
"appear as the first character in the escaped string\\&."
msgstr ""

#. type: Plain text
msgid ""
"When the input qualifies as absolute file system path, this algorithm is "
"extended slightly: the path to the root directory \"/\" is encoded as single "
"dash \"-\"\\&. In addition, any leading, trailing or duplicate \"/\" "
"characters are removed from the string before transformation\\&. Example: /"
"foo//bar/baz/ becomes \"foo-bar-baz\"\\&."
msgstr ""

#. type: Plain text
msgid ""
"This escaping is fully reversible, as long as it is known whether the "
"escaped string was a path (the unescaping results are different for paths "
"and non-path strings)\\&. The B<systemd-escape>(1)  command may be used to "
"apply and reverse escaping on arbitrary strings\\&. Use B<systemd-escape --"
"path> to escape path strings, and B<systemd-escape> without B<--path> "
"otherwise\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "IMPLICIT DEPENDENCIES"
msgstr "IMPLIZITE ABHÄNGIGKEITEN"

#. type: Plain text
msgid ""
"A number of unit dependencies are implicitly established, depending on unit "
"type and unit configuration\\&. These implicit dependencies can make unit "
"configuration file cleaner\\&. For the implicit dependencies in each unit "
"type, please refer to section \"Implicit Dependencies\" in respective man "
"pages\\&."
msgstr ""

#. type: Plain text
msgid ""
"For example, service units with I<Type=dbus> automatically acquire "
"dependencies of type I<Requires=> and I<After=> on dbus\\&.socket\\&. See "
"B<systemd.service>(5)  for details\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "DEFAULT DEPENDENCIES"
msgstr "STANDARD-ABHÄNGIGKEITEN"

#. type: Plain text
msgid ""
"Default dependencies are similar to implicit dependencies, but can be turned "
"on and off by setting I<DefaultDependencies=> to I<yes> (the default) and "
"I<no>, while implicit dependencies are always in effect\\&. See section "
"\"Default Dependencies\" in respective man pages for the effect of enabling "
"I<DefaultDependencies=> in each unit types\\&."
msgstr ""

#. type: Plain text
msgid ""
"For example, target units will complement all configured dependencies of "
"type I<Wants=> or I<Requires=> with dependencies of type I<After=> unless "
"I<DefaultDependencies=no> is set in the specified units\\&. See B<systemd."
"target>(5)  for details\\&. Note that this behavior can be turned off by "
"setting I<DefaultDependencies=no>\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "UNIT FILE LOAD PATH"
msgstr ""

#. type: Plain text
msgid ""
"Unit files are loaded from a set of paths determined during compilation, "
"described in the two tables below\\&. Unit files found in directories listed "
"earlier override files with the same name in directories lower in the list"
"\\&."
msgstr ""

#. type: Plain text
msgid ""
"When the variable I<$SYSTEMD_UNIT_PATH> is set, the contents of this "
"variable overrides the unit load path\\&. If I<$SYSTEMD_UNIT_PATH> ends with "
"an empty component (\":\"), the usual unit load path will be appended to the "
"contents of the variable\\&."
msgstr ""

#. type: Plain text
msgid ""
"B<Table\\ \\&1.\\ \\& Load path when running in system mode (--system)\\&.>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Path"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Description"
msgstr "Beschreibung"

#. type: tbl table
#, no-wrap
msgid ".T&"
msgstr ".T&"

#. type: tbl table
#, no-wrap
msgid "l l"
msgstr "l l"

#. type: tbl table
#, no-wrap
msgid "l l."
msgstr "l l."

#. type: tbl table
#, no-wrap
msgid "/etc/systemd/system"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Local configuration"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "/run/systemd/system"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Runtime units"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "/lib/systemd/system"
msgstr "/lib/systemd/system"

#. type: tbl table
#, no-wrap
msgid "Units of installed packages"
msgstr ""

#. type: Plain text
msgid "B<Table\\ \\&2.\\ \\& Load path when running in user mode (--user)\\&.>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "$XDG_CONFIG_HOME/systemd/user"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "User configuration (only used when $XDG_CONFIG_HOME is set)"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "$HOME/\\&.config/systemd/user"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "User configuration (only used when $XDG_CONFIG_HOME is not set)"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "/etc/systemd/user"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "$XDG_RUNTIME_DIR/systemd/user"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Runtime units (only used when $XDG_RUNTIME_DIR is set)"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "/run/systemd/user"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "$XDG_DATA_HOME/systemd/user"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Units of packages that have been installed in the home directory (only used when $XDG_DATA_HOME is set)"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "$HOME/\\&.local/share/systemd/user"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Units of packages that have been installed in the home directory (only used when $XDG_DATA_HOME is not set)"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "/usr/lib/systemd/user"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Units of packages that have been installed system-wide"
msgstr ""

#. type: Plain text
msgid ""
"Additional units might be loaded into systemd (\"linked\") from directories "
"not on the unit load path\\&. See the B<link> command for "
"B<systemctl>(1)\\&. Also, some units are dynamically created via a B<systemd."
"generator>(7)\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "UNIT GARBAGE COLLECTION"
msgstr ""

#. type: Plain text
msgid ""
"The system and service manager loads a unit\\*(Aqs configuration "
"automatically when a unit is referenced for the first time\\&. It will "
"automatically unload the unit configuration and state again when the unit is "
"not needed anymore (\"garbage collection\")\\&. A unit may be referenced "
"through a number of different mechanisms:"
msgstr ""

#. type: Plain text
msgid ""
"Another loaded unit references it with a dependency such as I<After=>, "
"I<Wants=>, \\&..."
msgstr ""

#. type: Plain text
msgid "The unit is currently starting, running, reloading or stopping\\&."
msgstr ""

#. type: Plain text
msgid "The unit is currently in the B<failed> state\\&. (But see below\\&.)"
msgstr ""

#. type: Plain text
msgid "A job for the unit is pending\\&."
msgstr ""

#. type: Plain text
msgid "The unit is pinned by an active IPC client program\\&."
msgstr ""

#. type: Plain text
msgid ""
"The unit is a special \"perpetual\" unit that is always active and loaded"
"\\&. Examples for perpetual units are the root mount unit -\\&.mount or the "
"scope unit init\\&.scope that the service manager itself lives in\\&."
msgstr ""

#. type: Plain text
msgid "The unit has running processes associated with it\\&."
msgstr ""

#. type: Plain text
msgid ""
"The garbage collection logic may be altered with the I<CollectMode=> option, "
"which allows configuration whether automatic unloading of units that are in "
"B<failed> state is permissible, see below\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that when a unit\\*(Aqs configuration and state is unloaded, all "
"execution results, such as exit codes, exit signals, resource consumption "
"and other statistics are lost, except for what is stored in the log subsystem"
"\\&."
msgstr ""

#. type: Plain text
msgid ""
"Use B<systemctl daemon-reload> or an equivalent command to reload unit "
"configuration while the unit is already loaded\\&. In this case all "
"configuration settings are flushed out and replaced with the new "
"configuration (which however might not be in effect immediately), however "
"all runtime state is saved/restored\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "[UNIT] SECTION OPTIONS"
msgstr ""

#. type: Plain text
msgid ""
"The unit file may include a [Unit] section, which carries generic "
"information about the unit that is not dependent on the type of unit:"
msgstr ""

#. type: Plain text
msgid "I<Description=>"
msgstr "I<Description=>"

#. type: Plain text
msgid ""
"A free-form string describing the unit\\&. This is intended for use in UIs "
"to show descriptive information along with the unit name\\&. The description "
"should contain a name that means something to the end user\\&.  \"Apache2 "
"Web Server\" is a good example\\&. Bad examples are \"high-performance light-"
"weight HTTP server\" (too generic) or \"Apache2\" (too specific and "
"meaningless for people who do not know Apache)\\&."
msgstr ""

#. type: Plain text
msgid "I<Documentation=>"
msgstr "I<Documentation=>"

#. type: Plain text
msgid ""
"A space-separated list of URIs referencing documentation for this unit or "
"its configuration\\&. Accepted are only URIs of the types \"http://\", "
"\"https://\", \"file:\", \"info:\", \"man:\"\\&. For more information about "
"the syntax of these URIs, see B<uri>(7)\\&. The URIs should be listed in "
"order of relevance, starting with the most relevant\\&. It is a good idea to "
"first reference documentation that explains what the unit\\*(Aqs purpose is, "
"followed by how it is configured, followed by any other related documentation"
"\\&. This option may be specified more than once, in which case the "
"specified list of URIs is merged\\&. If the empty string is assigned to this "
"option, the list is reset and all prior assignments will have no effect\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<Requires=>"
msgstr "I<Requires=>"

#. type: Plain text
msgid ""
"Configures requirement dependencies on other units\\&. If this unit gets "
"activated, the units listed here will be activated as well\\&. If one of the "
"other units fails to activate, and an ordering dependency I<After=> on the "
"failing unit is set, this unit will not be started\\&. Besides, with or "
"without specifying I<After=>, this unit will be deactivated if one of the "
"other units get deactivated\\&. This option may be specified more than once "
"or multiple space-separated units may be specified in one option in which "
"case requirement dependencies for all listed names will be created\\&. Note "
"that requirement dependencies do not influence the order in which services "
"are started or stopped\\&. This has to be configured independently with the "
"I<After=> or I<Before=> options\\&. If a unit foo\\&.service requires a unit "
"bar\\&.service as configured with I<Requires=> and no ordering is configured "
"with I<After=> or I<Before=>, then both units will be started simultaneously "
"and without any delay between them if foo\\&.service is activated\\&. Often, "
"it is a better choice to use I<Wants=> instead of I<Requires=> in order to "
"achieve a system that is more robust when dealing with failing services\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that this dependency type does not imply that the other unit always has "
"to be in active state when this unit is running\\&. Specifically: failing "
"condition checks (such as I<ConditionPathExists=>, "
"I<ConditionPathIsSymbolicLink=>, \\&... \\(em see below) do not cause the "
"start job of a unit with a I<Requires=> dependency on it to fail\\&. Also, "
"some unit types may deactivate on their own (for example, a service process "
"may decide to exit cleanly, or a device may be unplugged by the user), which "
"is not propagated to units having a I<Requires=> dependency\\&. Use the "
"I<BindsTo=> dependency type together with I<After=> to ensure that a unit "
"may never be in active state without a specific other unit also in active "
"state (see below)\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that dependencies of this type may also be configured outside of the "
"unit configuration file by adding a symlink to a \\&.requires/ directory "
"accompanying the unit file\\&. For details, see above\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<Requisite=>"
msgstr "I<Requisite=>"

#. type: Plain text
msgid ""
"Similar to I<Requires=>\\&. However, if the units listed here are not "
"started already, they will not be started and the transaction will fail "
"immediately\\&."
msgstr ""

#. type: Plain text
msgid ""
"When I<Requisite=b\\&.service> is used on a\\&.service, this dependency will "
"show as I<RequisiteOf=a\\&.service> in property listing of b\\&.service\\&.  "
"I<RequisiteOf=> dependency cannot be specified directly\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<Wants=>"
msgstr "I<Wants=>"

#. type: Plain text
msgid ""
"A weaker version of I<Requires=>\\&. Units listed in this option will be "
"started if the configuring unit is\\&. However, if the listed units fail to "
"start or cannot be added to the transaction, this has no impact on the "
"validity of the transaction as a whole\\&. This is the recommended way to "
"hook start-up of one unit to the start-up of another unit\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note that dependencies of this type may also be configured outside of the "
"unit configuration file by adding symlinks to a \\&.wants/ directory "
"accompanying the unit file\\&. For details, see above\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<BindsTo=>"
msgstr "I<BindsTo=>"

#. type: Plain text
msgid ""
"Configures requirement dependencies, very similar in style to I<Requires=>"
"\\&. However, this dependency type is stronger: in addition to the effect of "
"I<Requires=> it declares that if the unit bound to is stopped, this unit "
"will be stopped too\\&. This means a unit bound to another unit that "
"suddenly enters inactive state will be stopped too\\&. Units can suddenly, "
"unexpectedly enter inactive state for different reasons: the main process of "
"a service unit might terminate on its own choice, the backing device of a "
"device unit might be unplugged or the mount point of a mount unit might be "
"unmounted without involvement of the system and service manager\\&."
msgstr ""

#. type: Plain text
msgid ""
"When used in conjunction with I<After=> on the same unit the behaviour of "
"I<BindsTo=> is even stronger\\&. In this case, the unit bound to strictly "
"has to be in active state for this unit to also be in active state\\&. This "
"not only means a unit bound to another unit that suddenly enters inactive "
"state, but also one that is bound to another unit that gets skipped due to a "
"failed condition check (such as I<ConditionPathExists=>, "
"I<ConditionPathIsSymbolicLink=>, \\&... \\(em see below) will be stopped, "
"should it be running\\&. Hence, in many cases it is best to combine "
"I<BindsTo=> with I<After=>\\&."
msgstr ""

#. type: Plain text
msgid ""
"When I<BindsTo=b\\&.service> is used on a\\&.service, this dependency will "
"show as I<BoundBy=a\\&.service> in property listing of b\\&.service\\&.  "
"I<BoundBy=> dependency cannot be specified directly\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<PartOf=>"
msgstr "I<PartOf=>"

#. type: Plain text
msgid ""
"Configures dependencies similar to I<Requires=>, but limited to stopping and "
"restarting of units\\&. When systemd stops or restarts the units listed "
"here, the action is propagated to this unit\\&. Note that this is a one-way "
"dependency\\ \\&\\(em changes to this unit do not affect the listed units\\&."
msgstr ""

#. type: Plain text
msgid ""
"When I<PartOf=b\\&.service> is used on a\\&.service, this dependency will "
"show as I<ConsistsOf=a\\&.service> in property listing of b\\&.service\\&.  "
"I<ConsistsOf=> dependency cannot be specified directly\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<Conflicts=>"
msgstr "I<Conflicts=>"

#. type: Plain text
msgid ""
"A space-separated list of unit names\\&. Configures negative requirement "
"dependencies\\&. If a unit has a I<Conflicts=> setting on another unit, "
"starting the former will stop the latter and vice versa\\&. Note that this "
"setting is independent of and orthogonal to the I<After=> and I<Before=> "
"ordering dependencies\\&."
msgstr ""

#. type: Plain text
msgid ""
"If a unit A that conflicts with a unit B is scheduled to be started at the "
"same time as B, the transaction will either fail (in case both are required "
"part of the transaction) or be modified to be fixed (in case one or both "
"jobs are not a required part of the transaction)\\&. In the latter case, the "
"job that is not the required will be removed, or in case both are not "
"required, the unit that conflicts will be started and the unit that is "
"conflicted is stopped\\&."
msgstr ""

#. type: Plain text
msgid "I<Before=>, I<After=>"
msgstr ""

#. type: Plain text
msgid ""
"These two settings expect a space-separated list of unit names\\&. They "
"configure ordering dependencies between units\\&. If a unit foo\\&.service "
"contains a setting B<Before=bar\\&.service> and both units are being "
"started, bar\\&.service\\*(Aqs start-up is delayed until foo\\&.service has "
"finished starting up\\&. Note that this setting is independent of and "
"orthogonal to the requirement dependencies as configured by I<Requires=>, "
"I<Wants=> or I<BindsTo=>\\&. It is a common pattern to include a unit name "
"in both the I<After=> and I<Requires=> options, in which case the unit "
"listed will be started before the unit that is configured with these options"
"\\&. This option may be specified more than once, in which case ordering "
"dependencies for all listed names are created\\&.  I<After=> is the inverse "
"of I<Before=>, i\\&.e\\&. while I<After=> ensures that the configured unit "
"is started after the listed unit finished starting up, I<Before=> ensures "
"the opposite, that the configured unit is fully started up before the listed "
"unit is started\\&. Note that when two units with an ordering dependency "
"between them are shut down, the inverse of the start-up order is applied\\&. "
"i\\&.e\\&. if a unit is configured with I<After=> on another unit, the "
"former is stopped before the latter if both are shut down\\&. Given two "
"units with any ordering dependency between them, if one unit is shut down "
"and the other is started up, the shutdown is ordered before the start-up\\&. "
"It doesn\\*(Aqt matter if the ordering dependency is I<After=> or "
"I<Before=>, in this case\\&. It also doesn\\*(Aqt matter which of the two is "
"shut down, as long as one is shut down and the other is started up\\&. The "
"shutdown is ordered before the start-up in all cases\\&. If two units have "
"no ordering dependencies between them, they are shut down or started up "
"simultaneously, and no ordering takes place\\&. It depends on the unit type "
"when precisely a unit has finished starting up\\&. Most importantly, for "
"service units start-up is considered completed for the purpose of I<Before=>/"
"I<After=> when all its configured start-up commands have been invoked and "
"they either failed or reported start-up success\\&."
msgstr ""

#. type: Plain text
msgid "I<OnFailure=>"
msgstr "I<OnFailure=>"

#. type: Plain text
msgid ""
"A space-separated list of one or more units that are activated when this "
"unit enters the \"failed\" state\\&."
msgstr ""

#. type: Plain text
msgid "I<PropagatesReloadTo=>, I<ReloadPropagatedFrom=>"
msgstr ""

#. type: Plain text
msgid ""
"A space-separated list of one or more units where reload requests on this "
"unit will be propagated to, or reload requests on the other unit will be "
"propagated to this unit, respectively\\&. Issuing a reload request on a unit "
"will automatically also enqueue a reload request on all units that the "
"reload request shall be propagated to via these two settings\\&."
msgstr ""

#. type: Plain text
msgid "I<JoinsNamespaceOf=>"
msgstr "I<JoinsNamespaceOf=>"

#. type: Plain text
msgid ""
"For units that start processes (such as service units), lists one or more "
"other units whose network and/or temporary file namespace to join\\&. This "
"only applies to unit types which support the I<PrivateNetwork=> and "
"I<PrivateTmp=> directives (see B<systemd.exec>(5)  for details)\\&. If a "
"unit that has this setting set is started, its processes will see the same /"
"tmp, /var/tmp and network namespace as one listed unit that is started\\&. "
"If multiple listed units are already started, it is not defined which "
"namespace is joined\\&. Note that this setting only has an effect if "
"I<PrivateNetwork=> and/or I<PrivateTmp=> is enabled for both the unit that "
"joins the namespace and the unit whose namespace is joined\\&."
msgstr ""

#. type: Plain text
msgid "I<RequiresMountsFor=>"
msgstr "I<RequiresMountsFor=>"

#. type: Plain text
msgid ""
"Takes a space-separated list of absolute paths\\&. Automatically adds "
"dependencies of type I<Requires=> and I<After=> for all mount units required "
"to access the specified path\\&."
msgstr ""

#. type: Plain text
msgid ""
"Mount points marked with B<noauto> are not mounted automatically through "
"local-fs\\&.target, but are still honored for the purposes of this option, i"
"\\&.e\\&. they will be pulled in by this unit\\&."
msgstr ""

#. type: Plain text
msgid "I<OnFailureJobMode=>"
msgstr "I<OnFailureJobMode=>"

#. type: Plain text
msgid ""
"Takes a value of \"fail\", \"replace\", \"replace-irreversibly\", \"isolate"
"\", \"flush\", \"ignore-dependencies\" or \"ignore-requirements\"\\&. "
"Defaults to \"replace\"\\&. Specifies how the units listed in I<OnFailure=> "
"will be enqueued\\&. See B<systemctl>(1)\\*(Aqs B<--job-mode=> option for "
"details on the possible values\\&. If this is set to \"isolate\", only a "
"single unit may be listed in I<OnFailure=>\\&.\\&."
msgstr ""

#. type: Plain text
msgid "I<IgnoreOnIsolate=>"
msgstr "I<IgnoreOnIsolate=>"

#. type: Plain text
msgid ""
"Takes a boolean argument\\&. If B<true>, this unit will not be stopped when "
"isolating another unit\\&. Defaults to B<false> for service, target, socket, "
"busname, timer, and path units, and B<true> for slice, scope, device, swap, "
"mount, and automount units\\&."
msgstr ""

#. type: Plain text
msgid "I<StopWhenUnneeded=>"
msgstr "I<StopWhenUnneeded=>"

#. type: Plain text
msgid ""
"Takes a boolean argument\\&. If B<true>, this unit will be stopped when it "
"is no longer used\\&. Note that, in order to minimize the work to be "
"executed, systemd will not stop units by default unless they are conflicting "
"with other units, or the user explicitly requested their shut down\\&. If "
"this option is set, a unit will be automatically cleaned up if no other "
"active unit requires it\\&. Defaults to B<false>\\&."
msgstr ""

#. type: Plain text
msgid "I<RefuseManualStart=>, I<RefuseManualStop=>"
msgstr ""

#. type: Plain text
msgid ""
"Takes a boolean argument\\&. If B<true>, this unit can only be activated or "
"deactivated indirectly\\&. In this case, explicit start-up or termination "
"requested by the user is denied, however if it is started or stopped as a "
"dependency of another unit, start-up or termination will succeed\\&. This is "
"mostly a safety feature to ensure that the user does not accidentally "
"activate units that are not intended to be activated explicitly, and not "
"accidentally deactivate units that are not intended to be deactivated\\&. "
"These options default to B<false>\\&."
msgstr ""

#. type: Plain text
msgid "I<AllowIsolate=>"
msgstr "I<AllowIsolate=>"

#. type: Plain text
msgid ""
"Takes a boolean argument\\&. If B<true>, this unit may be used with the "
"B<systemctl isolate> command\\&. Otherwise, this will be refused\\&. It "
"probably is a good idea to leave this disabled except for target units that "
"shall be used similar to runlevels in SysV init systems, just as a "
"precaution to avoid unusable system states\\&. This option defaults to "
"B<false>\\&."
msgstr ""

#. type: Plain text
msgid "I<DefaultDependencies=>"
msgstr "I<DefaultDependencies=>"

#. type: Plain text
msgid ""
"Takes a boolean argument\\&. If B<true>, (the default), a few default "
"dependencies will implicitly be created for the unit\\&. The actual "
"dependencies created depend on the unit type\\&. For example, for service "
"units, these dependencies ensure that the service is started only after "
"basic system initialization is completed and is properly terminated on "
"system shutdown\\&. See the respective man pages for details\\&. Generally, "
"only services involved with early boot or late shutdown should set this "
"option to B<false>\\&. It is highly recommended to leave this option enabled "
"for the majority of common units\\&. If set to B<false>, this option does "
"not disable all implicit dependencies, just non-essential ones\\&."
msgstr ""

#. type: Plain text
msgid "I<CollectMode=>"
msgstr "I<CollectMode=>"

#. type: Plain text
msgid ""
"Tweaks the \"garbage collection\" algorithm for this unit\\&. Takes one of "
"B<inactive> or B<inactive-or-failed>\\&. If set to B<inactive> the unit will "
"be unloaded if it is in the B<inactive> state and is not referenced by "
"clients, jobs or other units \\(em however it is not unloaded if it is in "
"the B<failed> state\\&. In B<failed> mode, failed units are not unloaded "
"until the user invoked B<systemctl reset-failed> on them to reset the "
"B<failed> state, or an equivalent command\\&. This behaviour is altered if "
"this option is set to B<inactive-or-failed>: in this case the unit is "
"unloaded even if the unit is in a B<failed> state, and thus an explicitly "
"resetting of the B<failed> state is not necessary\\&. Note that if this mode "
"is used unit results (such as exit codes, exit signals, consumed resources, "
"\\&...) are flushed out immediately after the unit completed, except for "
"what is stored in the logging subsystem\\&. Defaults to B<inactive>\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<JobTimeoutSec=>, I<JobRunningTimeoutSec=>, I<JobTimeoutAction=>, "
"I<JobTimeoutRebootArgument=>"
msgstr ""

#. type: Plain text
msgid ""
"When a job for this unit is queued, a time-out I<JobTimeoutSec=> may be "
"configured\\&. Similarly, I<JobRunningTimeoutSec=> starts counting when the "
"queued job is actually started\\&. If either time limit is reached, the job "
"will be cancelled, the unit however will not change state or even enter the "
"\"failed\" mode\\&. This value defaults to \"infinity\" (job timeouts "
"disabled), except for device units (I<JobRunningTimeoutSec=> defaults to "
"I<DefaultTimeoutStartSec=>)\\&. NB: this timeout is independent from any "
"unit-specific timeout (for example, the timeout set with I<TimeoutStartSec=> "
"in service units) as the job timeout has no effect on the unit itself, only "
"on the job that might be pending for it\\&. Or in other words: unit-specific "
"timeouts are useful to abort unit state changes, and revert them\\&. The job "
"timeout set with this option however is useful to abort only the job waiting "
"for the unit state to change\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<JobTimeoutAction=> optionally configures an additional action to take when "
"the time-out is hit\\&. It takes the same values as I<StartLimitAction=>\\&. "
"Defaults to B<none>\\&.  I<JobTimeoutRebootArgument=> configures an optional "
"reboot string to pass to the B<reboot>(2)  system call\\&."
msgstr ""

#. type: Plain text
msgid "I<StartLimitIntervalSec=>I<interval>, I<StartLimitBurst=>I<burst>"
msgstr ""

#. type: Plain text
msgid ""
"Configure unit start rate limiting\\&. Units which are started more than "
"I<burst> times within an I<interval> time interval are not permitted to "
"start any more\\&. Use I<StartLimitIntervalSec=> to configure the checking "
"interval (defaults to I<DefaultStartLimitIntervalSec=> in manager "
"configuration file, set it to 0 to disable any kind of rate limiting)\\&. "
"Use I<StartLimitBurst=> to configure how many starts per interval are "
"allowed (defaults to I<DefaultStartLimitBurst=> in manager configuration "
"file)\\&. These configuration options are particularly useful in conjunction "
"with the service setting I<Restart=> (see B<systemd.service>(5)); however, "
"they apply to all kinds of starts (including manual), not just those "
"triggered by the I<Restart=> logic\\&. Note that units which are configured "
"for I<Restart=> and which reach the start limit are not attempted to be "
"restarted anymore; however, they may still be restarted manually at a later "
"point, after the I<interval> has passed\\&. From this point on, the restart "
"logic is activated again\\&. Note that B<systemctl reset-failed> will cause "
"the restart rate counter for a service to be flushed, which is useful if the "
"administrator wants to manually start a unit and the start limit interferes "
"with that\\&. Note that this rate-limiting is enforced after any unit "
"condition checks are executed, and hence unit activations with failing "
"conditions do not count towards this rate limit\\&. This setting does not "
"apply to slice, target, device, and scope units, since they are unit types "
"whose activation may either never fail, or may succeed only a single time\\&."
msgstr ""

#. type: Plain text
msgid ""
"When a unit is unloaded due to the garbage collection logic (see above) its "
"rate limit counters are flushed out too\\&. This means that configuring "
"start rate limiting for a unit that is not referenced continously has no "
"effect\\&."
msgstr ""

#. type: Plain text
msgid "I<StartLimitAction=>"
msgstr "I<StartLimitAction=>"

#. type: Plain text
msgid ""
"Configure the action to take if the rate limit configured with "
"I<StartLimitIntervalSec=> and I<StartLimitBurst=> is hit\\&. Takes one of "
"B<none>, B<reboot>, B<reboot-force>, B<reboot-immediate>, B<poweroff>, "
"B<poweroff-force> or B<poweroff-immediate>\\&. If B<none> is set, hitting "
"the rate limit will trigger no action besides that the start will not be "
"permitted\\&.  B<reboot> causes a reboot following the normal shutdown "
"procedure (i\\&.e\\&. equivalent to B<systemctl reboot>)\\&.  B<reboot-"
"force> causes a forced reboot which will terminate all processes forcibly "
"but should cause no dirty file systems on reboot (i\\&.e\\&. equivalent to "
"B<systemctl reboot -f>) and B<reboot-immediate> causes immediate execution "
"of the B<reboot>(2)  system call, which might result in data loss\\&. "
"Similarly, B<poweroff>, B<poweroff-force>, B<poweroff-immediate> have the "
"effect of powering down the system with similar semantics\\&. Defaults to "
"B<none>\\&."
msgstr ""

#. type: Plain text
msgid "I<FailureAction=>, I<SuccessAction=>"
msgstr ""

#. type: Plain text
msgid ""
"Configure the action to take when the unit stops and enters a failed state "
"or inactive state\\&. Takes the same values as the setting "
"I<StartLimitAction=> setting and executes the same actions (see B<systemd."
"unit>(5))\\&. Both options default to B<none>\\&."
msgstr ""

#. type: Plain text
msgid "I<RebootArgument=>"
msgstr "I<RebootArgument=>"

#. type: Plain text
msgid ""
"Configure the optional argument for the B<reboot>(2)  system call if "
"I<StartLimitAction=> or I<FailureAction=> is a reboot action\\&. This works "
"just like the optional argument to B<systemctl reboot> command\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionArchitecture=>, I<ConditionVirtualization=>, I<ConditionHost=>, "
"I<ConditionKernelCommandLine=>, I<ConditionSecurity=>, "
"I<ConditionCapability=>, I<ConditionACPower=>, I<ConditionNeedsUpdate=>, "
"I<ConditionFirstBoot=>, I<ConditionPathExists=>, "
"I<ConditionPathExistsGlob=>, I<ConditionPathIsDirectory=>, "
"I<ConditionPathIsSymbolicLink=>, I<ConditionPathIsMountPoint=>, "
"I<ConditionPathIsReadWrite=>, I<ConditionDirectoryNotEmpty=>, "
"I<ConditionFileNotEmpty=>, I<ConditionFileIsExecutable=>, I<ConditionUser=>, "
"I<ConditionGroup=>"
msgstr ""

#. type: Plain text
msgid ""
"Before starting a unit, verify that the specified condition is true\\&. If "
"it is not true, the starting of the unit will be (mostly silently) skipped, "
"however all ordering dependencies of it are still respected\\&. A failing "
"condition will not result in the unit being moved into a failure state\\&. "
"The condition is checked at the time the queued start job is to be executed"
"\\&. Use condition expressions in order to silently skip units that do not "
"apply to the local running system, for example because the kernel or runtime "
"environment doesn\\*(Aqt require its functionality\\&. Use the various "
"I<AssertArchitecture=>, I<AssertVirtualization=>, \\&... options for a "
"similar mechanism that puts the unit in a failure state and logs about the "
"failed check (see below)\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionArchitecture=> may be used to check whether the system is running "
"on a specific architecture\\&. Takes one of I<x86>, I<x86-64>, I<ppc>, I<ppc-"
"le>, I<ppc64>, I<ppc64-le>, I<ia64>, I<parisc>, I<parisc64>, I<s390>, "
"I<s390x>, I<sparc>, I<sparc64>, I<mips>, I<mips-le>, I<mips64>, I<mips64-"
"le>, I<alpha>, I<arm>, I<arm-be>, I<arm64>, I<arm64-be>, I<sh>, I<sh64>, "
"I<m68k>, I<tilegx>, I<cris>, I<arc>, I<arc-be> to test against a specific "
"architecture\\&. The architecture is determined from the information "
"returned by B<uname>(2)  and is thus subject to B<personality>(2)\\&. Note "
"that a I<Personality=> setting in the same unit file has no effect on this "
"condition\\&. A special architecture name I<native> is mapped to the "
"architecture the system manager itself is compiled for\\&. The test may be "
"negated by prepending an exclamation mark\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionVirtualization=> may be used to check whether the system is "
"executed in a virtualized environment and optionally test whether it is a "
"specific implementation\\&. Takes either boolean value to check if being "
"executed in any virtualized environment, or one of I<vm> and I<container> to "
"test against a generic type of virtualization solution, or one of I<qemu>, "
"I<kvm>, I<zvm>, I<vmware>, I<microsoft>, I<oracle>, I<xen>, I<bochs>, "
"I<uml>, I<openvz>, I<lxc>, I<lxc-libvirt>, I<systemd-nspawn>, I<docker>, "
"I<rkt> to test against a specific implementation, or I<private-users> to "
"check whether we are running in a user namespace\\&. See B<systemd-detect-"
"virt>(1)  for a full list of known virtualization technologies and their "
"identifiers\\&. If multiple virtualization technologies are nested, only the "
"innermost is considered\\&. The test may be negated by prepending an "
"exclamation mark\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionHost=> may be used to match against the hostname or machine ID of "
"the host\\&. This either takes a hostname string (optionally with shell "
"style globs) which is tested against the locally set hostname as returned by "
"B<gethostname>(2), or a machine ID formatted as string (see B<machine-"
"id>(5))\\&. The test may be negated by prepending an exclamation mark\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionKernelCommandLine=> may be used to check whether a specific "
"kernel command line option is set (or if prefixed with the exclamation mark "
"unset)\\&. The argument must either be a single word, or an assignment (i\\&."
"e\\&. two words, separated \"=\")\\&. In the former case the kernel command "
"line is searched for the word appearing as is, or as left hand side of an "
"assignment\\&. In the latter case, the exact assignment is looked for with "
"right and left hand side matching\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionSecurity=> may be used to check whether the given security module "
"is enabled on the system\\&. Currently, the recognized values are "
"I<selinux>, I<apparmor>, I<tomoyo>, I<ima>, I<smack> and I<audit>\\&. The "
"test may be negated by prepending an exclamation mark\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionCapability=> may be used to check whether the given capability "
"exists in the capability bounding set of the service manager (i\\&.e\\&. "
"this does not check whether capability is actually available in the "
"permitted or effective sets, see B<capabilities>(7)  for details)\\&. Pass a "
"capability name such as \"CAP_MKNOD\", possibly prefixed with an exclamation "
"mark to negate the check\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionACPower=> may be used to check whether the system has AC power, "
"or is exclusively battery powered at the time of activation of the unit\\&. "
"This takes a boolean argument\\&. If set to I<true>, the condition will hold "
"only if at least one AC connector of the system is connected to a power "
"source, or if no AC connectors are known\\&. Conversely, if set to I<false>, "
"the condition will hold only if there is at least one AC connector known and "
"all AC connectors are disconnected from a power source\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionNeedsUpdate=> takes one of /var or /etc as argument, possibly "
"prefixed with a \"!\" (for inverting the condition)\\&. This condition may "
"be used to conditionalize units on whether the specified directory requires "
"an update because /usr\\*(Aqs modification time is newer than the stamp file "
"\\&.updated in the specified directory\\&. This is useful to implement "
"offline updates of the vendor operating system resources in /usr that "
"require updating of /etc or /var on the next following boot\\&. Units making "
"use of this condition should order themselves before B<systemd-update-done."
"service>(8), to make sure they run before the stamp file\\*(Aqs modification "
"time gets reset indicating a completed update\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionFirstBoot=> takes a boolean argument\\&. This condition may be "
"used to conditionalize units on whether the system is booting up with an "
"unpopulated /etc directory (specifically: an /etc with no /etc/machine-"
"id)\\&. This may be used to populate /etc on the first boot after factory "
"reset, or when a new system instance boots up for the first time\\&."
msgstr ""

#. type: Plain text
msgid ""
"With I<ConditionPathExists=> a file existence condition is checked before a "
"unit is started\\&. If the specified absolute path name does not exist, the "
"condition will fail\\&. If the absolute path name passed to "
"I<ConditionPathExists=> is prefixed with an exclamation mark (\"!\"), the "
"test is negated, and the unit is only started if the path does not exist\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionPathExistsGlob=> is similar to I<ConditionPathExists=>, but "
"checks for the existence of at least one file or directory matching the "
"specified globbing pattern\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionPathIsDirectory=> is similar to I<ConditionPathExists=> but "
"verifies whether a certain path exists and is a directory\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionPathIsSymbolicLink=> is similar to I<ConditionPathExists=> but "
"verifies whether a certain path exists and is a symbolic link\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionPathIsMountPoint=> is similar to I<ConditionPathExists=> but "
"verifies whether a certain path exists and is a mount point\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionPathIsReadWrite=> is similar to I<ConditionPathExists=> but "
"verifies whether the underlying file system is readable and writable (i\\&.e"
"\\&. not mounted read-only)\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionDirectoryNotEmpty=> is similar to I<ConditionPathExists=> but "
"verifies whether a certain path exists and is a non-empty directory\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionFileNotEmpty=> is similar to I<ConditionPathExists=> but verifies "
"whether a certain path exists and refers to a regular file with a non-zero "
"size\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionFileIsExecutable=> is similar to I<ConditionPathExists=> but "
"verifies whether a certain path exists, is a regular file and marked "
"executable\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionUser=> takes a numeric \"UID\", a UNIX user name, or the special "
"value \"@system\"\\&. This condition may be used to check whether the "
"service manager is running as the given user\\&. The special value \"@system"
"\" can be used to check if the user id is within the system user range\\&. "
"This option is not useful for system services, as the system manager "
"exclusively runs as the root user, and thus the test result is constant\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<ConditionGroup=> is similar to I<ConditionUser=> but verifies that the "
"service manager\\*(Aqs real or effective group, or any of its auxiliary "
"groups match the specified group or GID\\&. This setting does not have a "
"special value \"@system\"\\&."
msgstr ""

#. type: Plain text
msgid ""
"If multiple conditions are specified, the unit will be executed if all of "
"them apply (i\\&.e\\&. a logical AND is applied)\\&. Condition checks can be "
"prefixed with a pipe symbol (|) in which case a condition becomes a "
"triggering condition\\&. If at least one triggering condition is defined for "
"a unit, then the unit will be executed if at least one of the triggering "
"conditions apply and all of the non-triggering conditions\\&. If you prefix "
"an argument with the pipe symbol and an exclamation mark, the pipe symbol "
"must be passed first, the exclamation second\\&. Except for "
"I<ConditionPathIsSymbolicLink=>, all path checks follow symlinks\\&. If any "
"of these options is assigned the empty string, the list of conditions is "
"reset completely, all previous condition settings (of any kind) will have no "
"effect\\&."
msgstr ""

#. type: Plain text
msgid ""
"I<AssertArchitecture=>, I<AssertVirtualization=>, I<AssertHost=>, "
"I<AssertKernelCommandLine=>, I<AssertSecurity=>, I<AssertCapability=>, "
"I<AssertACPower=>, I<AssertNeedsUpdate=>, I<AssertFirstBoot=>, "
"I<AssertPathExists=>, I<AssertPathExistsGlob=>, I<AssertPathIsDirectory=>, "
"I<AssertPathIsSymbolicLink=>, I<AssertPathIsMountPoint=>, "
"I<AssertPathIsReadWrite=>, I<AssertDirectoryNotEmpty=>, "
"I<AssertFileNotEmpty=>, I<AssertFileIsExecutable=>, I<AssertUser=>, "
"I<AssertGroup=>"
msgstr ""

#. type: Plain text
msgid ""
"Similar to the I<ConditionArchitecture=>, I<ConditionVirtualization=>, "
"\\&..., condition settings described above, these settings add assertion "
"checks to the start-up of the unit\\&. However, unlike the conditions "
"settings, any assertion setting that is not met results in failure of the "
"start job (which means this is logged loudly)\\&. Use assertion expressions "
"for units that cannot operate when specific requirements are not met, and "
"when this is something the administrator or user should look into\\&."
msgstr ""

#. type: Plain text
msgid "I<SourcePath=>"
msgstr "I<SourcePath=>"

#. type: Plain text
msgid ""
"A path to a configuration file this unit has been generated from\\&. This is "
"primarily useful for implementation of generator tools that convert "
"configuration from an external configuration file format into native unit "
"files\\&. This functionality should not be used in normal units\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "MAPPING OF UNIT PROPERTIES TO THEIR INVERSES"
msgstr ""

#. type: Plain text
msgid ""
"Unit settings that create a relationship with a second unit usually show up "
"in properties of both units, for example in B<systemctl show> output\\&. In "
"some cases the name of the property is the same as the name of the "
"configuration setting, but not always\\&. This table lists the pairs of "
"properties that are shown on two units which are connected through some "
"dependency, and shows which property on \"source\" unit corresponds to which "
"property on the \"target\" unit\\&."
msgstr ""

#. type: Plain text
msgid "B<Table\\ \\&3.\\ \\& Forward and reverse unit properties>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "\"Forward\" property"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "\"Reverse\" property"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Where used"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "l l l"
msgstr "l l l"

#. type: tbl table
#, no-wrap
msgid "l l ^"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "l l ^."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<Before=>"
msgstr "I<Before=>"

#. type: tbl table
#, no-wrap
msgid "I<After=>"
msgstr "I<After=>"

#. type: tbl table
#, no-wrap
msgid "Both are unit file options"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<RequiredBy=>"
msgstr "I<RequiredBy=>"

#. type: tbl table
#, no-wrap
msgid "A unit file option; an option in the [Install] section"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<WantedBy=>"
msgstr "I<WantedBy=>"

#. type: tbl table
#, no-wrap
msgid "I<ConsistsOf=>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "A unit file option; an automatic property"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<BoundBy=>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<RequisiteOf=>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<Triggers=>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<TriggeredBy=>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Automatic properties, see notes below"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<ConflictedBy=>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "I<PropagatesReloadTo=>"
msgstr "I<PropagatesReloadTo=>"

#. type: tbl table
#, no-wrap
msgid "I<ReloadPropagatedFrom=>"
msgstr "I<ReloadPropagatedFrom=>"

#. type: Plain text
msgid ""
"Note: I<WantedBy=> and I<RequiredBy=> are used in the [Install] section to "
"create symlinks in \\&.wants/ and \\&.requires/ directories\\&. They cannot "
"be used directly as a unit configuration setting\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note: I<ConsistsOf=>, I<BoundBy=>, I<RequisiteOf=>, I<ConflictedBy=> are "
"created implicitly along with their reverse and cannot be specified directly"
"\\&."
msgstr ""

#. type: Plain text
msgid ""
"Note: I<Triggers=> is created implicitly between a socket, path unit, or an "
"automount unit, and the unit they activate\\&. By default a unit with the "
"same name is triggered, but this can be overriden using I<Sockets=>, "
"I<Service=>, and I<Unit=> settings\\&. See B<systemd.service>(5), B<systemd."
"socket>(5), B<systemd.path>(5), and B<systemd.automount>(5)  for details"
"\\&.  I<TriggersBy=> is created implicitly on the triggered unit\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "[INSTALL] SECTION OPTIONS"
msgstr ""

#. type: Plain text
msgid ""
"Unit files may include an \"[Install]\" section, which carries installation "
"information for the unit\\&. This section is not interpreted by "
"B<systemd>(1)  during runtime; it is used by the B<enable> and B<disable> "
"commands of the B<systemctl>(1)  tool during installation of a unit\\&."
msgstr ""

#. type: Plain text
msgid "I<Alias=>"
msgstr "I<Alias=>"

#. type: Plain text
msgid ""
"A space-separated list of additional names this unit shall be installed under"
"\\&. The names listed here must have the same suffix (i\\&.e\\&. type) as "
"the unit filename\\&. This option may be specified more than once, in which "
"case all listed names are used\\&. At installation time, B<systemctl enable> "
"will create symlinks from these names to the unit filename\\&. Note that not "
"all unit types support such alias names, and this setting is not supported "
"for them\\&. Specifically, mount, slice, swap, and automount units do not "
"support aliasing\\&."
msgstr ""

#. type: Plain text
msgid "I<WantedBy=>, I<RequiredBy=>"
msgstr ""

#. type: Plain text
msgid ""
"This option may be used more than once, or a space-separated list of unit "
"names may be given\\&. A symbolic link is created in the \\&.wants/ or \\&."
"requires/ directory of each of the listed units when this unit is installed "
"by B<systemctl enable>\\&. This has the effect that a dependency of type "
"I<Wants=> or I<Requires=> is added from the listed unit to the current unit"
"\\&. The primary result is that the current unit will be started when the "
"listed unit is started\\&. See the description of I<Wants=> and I<Requires=> "
"in the [Unit] section for details\\&."
msgstr ""

#. type: Plain text
msgid ""
"B<WantedBy=foo\\&.service> in a service bar\\&.service is mostly equivalent "
"to B<Alias=foo\\&.service\\&.wants/bar\\&.service> in the same file\\&. In "
"case of template units, B<systemctl enable> must be called with an instance "
"name, and this instance will be added to the \\&.wants/ or \\&.requires/ "
"list of the listed unit\\&. E\\&.g\\&.  B<WantedBy=getty\\&.target> in a "
"service getty@\\&.service will result in B<systemctl enable getty@tty2\\&."
"service> creating a getty\\&.target\\&.wants/getty@tty2\\&.service link to "
"getty@\\&.service\\&."
msgstr ""

#. type: Plain text
msgid "I<Also=>"
msgstr "I<Also=>"

#. type: Plain text
msgid ""
"Additional units to install/deinstall when this unit is installed/deinstalled"
"\\&. If the user requests installation/deinstallation of a unit with this "
"option configured, B<systemctl enable> and B<systemctl disable> will "
"automatically install/uninstall units listed in this option as well\\&."
msgstr ""

#. type: Plain text
msgid ""
"This option may be used more than once, or a space-separated list of unit "
"names may be given\\&."
msgstr ""

#. type: Plain text
msgid "I<DefaultInstance=>"
msgstr "I<DefaultInstance=>"

#. type: Plain text
msgid ""
"In template unit files, this specifies for which instance the unit shall be "
"enabled if the template is enabled without any explicitly set instance\\&. "
"This option has no effect in non-template unit files\\&. The specified "
"string must be usable as instance identifier\\&."
msgstr ""

#. type: Plain text
msgid ""
"The following specifiers are interpreted in the Install section: %n, %N, %p, "
"%i, %U, %u, %m, %H, %b, %v\\&. For their meaning see the next section\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "SPECIFIERS"
msgstr ""

#. type: Plain text
msgid ""
"Many settings resolve specifiers which may be used to write generic unit "
"files referring to runtime or unit parameters that are replaced when the "
"unit files are loaded\\&. Specifiers must be known and resolvable for the "
"setting to be valid\\&. The following specifiers are understood:"
msgstr ""

#. type: Plain text
msgid "B<Table\\ \\&4.\\ \\&Specifiers available in unit files>"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Specifier"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Meaning"
msgstr "Bedeutung"

#. type: tbl table
#, no-wrap
msgid "Details"
msgstr "Details"

#. type: tbl table
#, no-wrap
msgid "l l l."
msgstr "l l l."

#. type: tbl table
#, no-wrap
msgid "%n"
msgstr "%n"

#. type: tbl table
#, no-wrap
msgid "Full unit name"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "\\ \\&"
msgstr "\\ \\&"

#. type: tbl table
#, no-wrap
msgid "%N"
msgstr "%N"

#. type: tbl table
#, no-wrap
msgid "Unescaped full unit name"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Same as \"%n\", but with escaping undone\\&. This undoes the escaping used when generating unit names from arbitrary strings (see above)\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%p"
msgstr "%p"

#. type: tbl table
#, no-wrap
msgid "Prefix name"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "For instantiated units, this refers to the string before the \"@\" character of the unit name\\&. For non-instantiated units, this refers to the name of the unit with the type suffix removed\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%P"
msgstr "%P"

#. type: tbl table
#, no-wrap
msgid "Unescaped prefix name"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Same as \"%p\", but with escaping undone"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%i"
msgstr "%i"

#. type: tbl table
#, no-wrap
msgid "Instance name"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "For instantiated units: this is the string between the \"@\" character and the suffix of the unit name\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%I"
msgstr "%I"

#. type: tbl table
#, no-wrap
msgid "Unescaped instance name"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Same as \"%i\", but with escaping undone"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%f"
msgstr "%f"

#. type: tbl table
#, no-wrap
msgid "Unescaped filename"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is either the unescaped instance name (if applicable) with / prepended (if applicable), or the unescaped prefix name prepended with /\\&. This implements unescaping according to the rules for escaping absolute file system paths discussed above\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%t"
msgstr "%t"

#. type: tbl table
#, no-wrap
msgid "Runtime directory root"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is either /run (for the system manager) or the path \"$XDG_RUNTIME_DIR\" resolves to (for user managers)\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%S"
msgstr "%S"

#. type: tbl table
#, no-wrap
msgid "State directory root"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is either /var/lib (for the system manager) or the path \"$XDG_CONFIG_HOME\" resolves to (for user managers)\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%C"
msgstr "%C"

#. type: tbl table
#, no-wrap
msgid "Cache directory root"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is either /var/cache (for the system manager) or the path \"$XDG_CACHE_HOME\" resolves to (for user managers)\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%L"
msgstr "%L"

#. type: tbl table
#, no-wrap
msgid "Log directory root"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is either /var/log (for the system manager) or the path \"$XDG_CONFIG_HOME\" resolves to with /log appended (for user managers)\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%u"
msgstr "%u"

#. type: tbl table
#, no-wrap
msgid "User name"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is the name of the user running the service manager instance\\&. In case of the system manager this resolves to \"root\"\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%U"
msgstr "%U"

#. type: tbl table
#, no-wrap
msgid "User UID"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is the numeric UID of the user running the service manager instance\\&. In case of the system manager this resolves to \"0\"\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%h"
msgstr "%h"

#. type: tbl table
#, no-wrap
msgid "User home directory"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is the home directory of the user running the service manager instance\\&. In case of the system manager this resolves to \"/root\"\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%s"
msgstr "%s"

#. type: tbl table
#, no-wrap
msgid "User shell"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "This is the shell of the user running the service manager instance\\&. In case of the system manager this resolves to \"/bin/sh\"\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%m"
msgstr "%m"

#. type: tbl table
#, no-wrap
msgid "Machine ID"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "The machine ID of the running system, formatted as string\\&. See B<machine-id>(5) for more information\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%b"
msgstr "%b"

#. type: tbl table
#, no-wrap
msgid "Boot ID"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "The boot ID of the running system, formatted as string\\&. See B<random>(4) for more information\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%H"
msgstr "%H"

#. type: tbl table
#, no-wrap
msgid "Host name"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "The hostname of the running system at the point in time the unit configuration is loaded\\&."
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%v"
msgstr "%v"

#. type: tbl table
#, no-wrap
msgid "Kernel release"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Identical to B<uname -r> output"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "%%"
msgstr "%%"

#. type: tbl table
#, no-wrap
msgid "Single percent sign"
msgstr ""

#. type: tbl table
#, no-wrap
msgid "Use \"%%\" in place of \"%\" to specify a single percent sign\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "EXAMPLES"
msgstr "BEISPIELE"

#. type: Plain text
msgid "B<Example\\ \\&1.\\ \\&Allowing units to be enabled>"
msgstr ""

#. type: Plain text
msgid ""
"The following snippet (highlighted) allows a unit (e\\&.g\\&.  foo\\&."
"service) to be enabled via B<systemctl enable>:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Unit]\n"
"Description=Foo\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Service]\n"
"ExecStart=/usr/sbin/foo-daemon\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"I<[Install]>\n"
"I<WantedBy=multi-user\\&.target>\n"
msgstr ""

#. type: Plain text
msgid ""
"After running B<systemctl enable>, a symlink /etc/systemd/system/multi-user"
"\\&.target\\&.wants/foo\\&.service linking to the actual unit will be created"
"\\&. It tells systemd to pull in the unit when starting multi-user\\&.target"
"\\&. The inverse B<systemctl disable> will remove that symlink again\\&."
msgstr ""

#. type: Plain text
msgid "B<Example\\ \\&2.\\ \\&Overriding vendor settings>"
msgstr ""

#. type: Plain text
msgid ""
"There are two methods of overriding vendor settings in unit files: copying "
"the unit file from /lib/systemd/system to /etc/systemd/system and modifying "
"the chosen settings\\&. Alternatively, one can create a directory named "
"I<unit>\\&.d/ within /etc/systemd/system and place a drop-in file I<name>\\&."
"conf there that only changes the specific settings one is interested in\\&. "
"Note that multiple such drop-in files are read if present, processed in "
"lexicographic order of their filename\\&."
msgstr ""

#. type: Plain text
msgid ""
"The advantage of the first method is that one easily overrides the complete "
"unit, the vendor unit is not parsed at all anymore\\&. It has the "
"disadvantage that improvements to the unit file by the vendor are not "
"automatically incorporated on updates\\&."
msgstr ""

#. type: Plain text
msgid ""
"The advantage of the second method is that one only overrides the settings "
"one specifically wants, where updates to the unit by the vendor "
"automatically apply\\&. This has the disadvantage that some future updates "
"by the vendor might be incompatible with the local changes\\&."
msgstr ""

#. type: Plain text
msgid ""
"This also applies for user instances of systemd, but with different "
"locations for the unit files\\&. See the section on unit load paths for "
"further details\\&."
msgstr ""

#. type: Plain text
msgid ""
"Suppose there is a vendor-supplied unit /lib/systemd/system/httpd\\&.service "
"with the following contents:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Unit]\n"
"Description=Some HTTP server\n"
"After=remote-fs\\&.target sqldb\\&.service\n"
"Requires=sqldb\\&.service\n"
"AssertPathExists=/srv/webserver\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Service]\n"
"Type=notify\n"
"ExecStart=/usr/sbin/some-fancy-httpd-server\n"
"Nice=5\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Install]\n"
"WantedBy=multi-user\\&.target\n"
msgstr ""

#. type: Plain text
msgid ""
"Now one wants to change some settings as an administrator: firstly, in the "
"local setup, /srv/webserver might not exist, because the HTTP server is "
"configured to use /srv/www instead\\&. Secondly, the local configuration "
"makes the HTTP server also depend on a memory cache service, memcached\\&."
"service, that should be pulled in (I<Requires=>) and also be ordered "
"appropriately (I<After=>)\\&. Thirdly, in order to harden the service a bit "
"more, the administrator would like to set the I<PrivateTmp=> setting (see "
"B<systemd.exec>(5)  for details)\\&. And lastly, the administrator would "
"like to reset the niceness of the service to its default value of 0\\&."
msgstr ""

#. type: Plain text
msgid ""
"The first possibility is to copy the unit file to /etc/systemd/system/httpd"
"\\&.service and change the chosen settings:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Unit]\n"
"Description=Some HTTP server\n"
"After=remote-fs\\&.target sqldb\\&.service I<memcached\\&.service>\n"
"Requires=sqldb\\&.service I<memcached\\&.service>\n"
"AssertPathExists=I</srv/www>\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Service]\n"
"Type=notify\n"
"ExecStart=/usr/sbin/some-fancy-httpd-server\n"
"I<Nice=0>\n"
"I<PrivateTmp=yes>\n"
msgstr ""

#. type: Plain text
msgid ""
"Alternatively, the administrator could create a drop-in file /etc/systemd/"
"system/httpd\\&.service\\&.d/local\\&.conf with the following contents:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Unit]\n"
"After=memcached\\&.service\n"
"Requires=memcached\\&.service\n"
"# Reset all assertions and then re-add the condition we want\n"
"AssertPathExists=\n"
"AssertPathExists=/srv/www\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"[Service]\n"
"Nice=0\n"
"PrivateTmp=yes\n"
msgstr ""

#. type: Plain text
msgid ""
"Note that for drop-in files, if one wants to remove entries from a setting "
"that is parsed as a list (and is not a dependency), such as "
"I<AssertPathExists=> (or e\\&.g\\&.  I<ExecStart=> in service units), one "
"needs to first clear the list before re-adding all entries except the one "
"that is to be removed\\&. Dependencies (I<After=>, etc\\&.) cannot be reset "
"to an empty list, so dependencies can only be added in drop-ins\\&. If you "
"want to remove dependencies, you have to override the entire unit\\&."
msgstr ""

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr "SIEHE AUCH"

#. type: Plain text
msgid ""
"B<systemd>(1), B<systemctl>(1), B<systemd.special>(7), B<systemd."
"service>(5), B<systemd.socket>(5), B<systemd.device>(5), B<systemd."
"mount>(5), B<systemd.automount>(5), B<systemd.swap>(5), B<systemd."
"target>(5), B<systemd.path>(5), B<systemd.timer>(5), B<systemd.scope>(5), "
"B<systemd.slice>(5), B<systemd.time>(7), B<systemd-analyze>(1), "
"B<capabilities>(7), B<systemd.directives>(7), B<uname>(1)"
msgstr ""

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr "ANMERKUNGEN"

#. type: IP
#, no-wrap
msgid " 1."
msgstr " 1."

#. type: Plain text
msgid "XDG Desktop Entry Specification"
msgstr ""

#. type: Plain text
msgid "\\%http://standards.freedesktop.org/desktop-entry-spec/latest/"
msgstr ""

#. type: IP
#, no-wrap
msgid " 2."
msgstr " 2."

#. type: Plain text
msgid "Interface Stability Promise"
msgstr ""

#. type: Plain text
msgid ""
"\\%https://www.freedesktop.org/wiki/Software/systemd/"
"InterfaceStabilityPromise"
msgstr ""
"\\%https://www.freedesktop.org/wiki/Software/systemd/"
"InterfaceStabilityPromise"
