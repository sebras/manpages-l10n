# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2017-07-23 16:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#, no-wrap
msgid "CLONE"
msgstr ""

#. type: TH
#, no-wrap
msgid "2017-05-03"
msgstr ""

#. type: TH
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
msgid "clone, __clone2 - create a child process"
msgstr ""

#. type: SH
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "/* Prototype for the glibc wrapper function */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"B<int clone(int (*>I<fn>B<)(void *), void *>I<child_stack>B<,>\n"
"B<          int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, void *>I<newtls>B<, pid_t *>I<ctid>B< */ "
");>\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "/* For the prototype of the raw system call, see NOTES */\n"
msgstr ""

#. type: SH
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
msgid "B<clone>()  creates a new process, in a manner similar to B<fork>(2)."
msgstr ""

#. type: Plain text
msgid ""
"This page describes both the glibc B<clone>()  wrapper function and the "
"underlying system call on which it is based.  The main text describes the "
"wrapper function; the differences for the raw system call are described "
"toward the end of this page."
msgstr ""

#. type: Plain text
msgid ""
"Unlike B<fork>(2), B<clone>()  allows the child process to share parts of "
"its execution context with the calling process, such as the memory space, "
"the table of file descriptors, and the table of signal handlers.  (Note that "
"on this manual page, \"calling process\" normally corresponds to \"parent "
"process\".  But see the description of B<CLONE_PARENT> below.)"
msgstr ""

#. type: Plain text
msgid ""
"One use of B<clone>()  is to implement threads: multiple threads of control "
"in a program that run concurrently in a shared memory space."
msgstr ""

#. type: Plain text
msgid ""
"When the child process is created with B<clone>(), it executes the function "
"I<fn>(I<arg>).  (This differs from B<fork>(2), where execution continues in "
"the child from the point of the B<fork>(2)  call.)  The I<fn> argument is a "
"pointer to a function that is called by the child process at the beginning "
"of its execution.  The I<arg> argument is passed to the I<fn> function."
msgstr ""

#. type: Plain text
msgid ""
"When the I<fn>(I<arg>)  function application returns, the child process "
"terminates.  The integer returned by I<fn> is the exit code for the child "
"process.  The child process may also terminate explicitly by calling "
"B<exit>(2)  or after receiving a fatal signal."
msgstr ""

#. type: Plain text
msgid ""
"The I<child_stack> argument specifies the location of the stack used by the "
"child process.  Since the child and calling process may share memory, it is "
"not possible for the child process to execute in the same stack as the "
"calling process.  The calling process must therefore set up memory space for "
"the child stack and pass a pointer to this space to B<clone>().  Stacks grow "
"downward on all processors that run Linux (except the HP PA processors), so "
"I<child_stack> usually points to the topmost address of the memory space set "
"up for the child stack."
msgstr ""

#. type: Plain text
msgid ""
"The low byte of I<flags> contains the number of the I<termination signal> "
"sent to the parent when the child dies.  If this signal is specified as "
"anything other than B<SIGCHLD>, then the parent process must specify the "
"B<__WALL> or B<__WCLONE> options when waiting for the child with "
"B<wait>(2).  If no signal is specified, then the parent process is not "
"signaled when the child terminates."
msgstr ""

#. type: Plain text
msgid ""
"I<flags> may also be bitwise-or'ed with zero or more of the following "
"constants, in order to specify what is shared between the calling process "
"and the child process:"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_CHILD_CLEARTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
msgid ""
"Clear (zero) the child thread ID at the location I<ctid> in child memory "
"when the child exits, and do a wakeup on the futex at that address.  The "
"address involved may be changed by the B<set_tid_address>(2)  system call.  "
"This is used by threading libraries."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_CHILD_SETTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
msgid ""
"Store the child thread ID at the location I<ctid> in the child's memory.  "
"The store operation completes before B<clone>()  returns control to user "
"space."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_FILES> (since Linux 2.0)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_FILES> is set, the calling process and the child process share "
"the same file descriptor table.  Any file descriptor created by the calling "
"process or by the child process is also valid in the other process.  "
"Similarly, if one of the processes closes a file descriptor, or changes its "
"associated flags (using the B<fcntl>(2)  B<F_SETFD> operation), the other "
"process is also affected.  If a process sharing a file descriptor table "
"calls B<execve>(2), its file descriptor table is duplicated (unshared)."
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_FILES> is not set, the child process inherits a copy of all file "
"descriptors opened in the calling process at the time of B<clone>().  "
"Subsequent operations that open or close file descriptors, or change file "
"descriptor flags, performed by either the calling process or the child "
"process do not affect the other process.  Note, however, that the duplicated "
"file descriptors in the child refer to the same open file descriptions as "
"the corresponding file descriptors in the calling process, and thus share "
"file offsets and file status flags (see B<open>(2))."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_FS> (since Linux 2.0)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_FS> is set, the caller and the child process share the same "
"filesystem information.  This includes the root of the filesystem, the "
"current working directory, and the umask.  Any call to B<chroot>(2), "
"B<chdir>(2), or B<umask>(2)  performed by the calling process or the child "
"process also affects the other process."
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_FS> is not set, the child process works on a copy of the "
"filesystem information of the calling process at the time of the B<clone>()  "
"call.  Calls to B<chroot>(2), B<chdir>(2), B<umask>(2)  performed later by "
"one of the processes do not affect the other process."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_IO> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_IO> is set, then the new process shares an I/O context with the "
"calling process.  If this flag is not set, then (as with B<fork>(2))  the "
"new process has its own I/O context."
msgstr ""

#.  The following based on text from Jens Axboe
#.  the anticipatory and CFQ scheduler
#.  with CFQ and AS.
#. type: Plain text
msgid ""
"The I/O context is the I/O scope of the disk scheduler (i.e., what the I/O "
"scheduler uses to model scheduling of a process's I/O).  If processes share "
"the same I/O context, they are treated as one by the I/O scheduler.  As a "
"consequence, they get to share disk time.  For some I/O schedulers, if two "
"processes share an I/O context, they will be allowed to interleave their "
"disk access.  If several threads are doing I/O on behalf of the same process "
"(B<aio_read>(3), for instance), they should employ B<CLONE_IO> to get better "
"I/O performance."
msgstr ""

#. type: Plain text
msgid ""
"If the kernel is not configured with the B<CONFIG_BLOCK> option, this flag "
"is a no-op."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_NEWCGROUP> (since Linux 4.6)"
msgstr ""

#. type: Plain text
msgid ""
"Create the process in a new cgroup namespace.  If this flag is not set, then "
"(as with B<fork>(2))  the process is created in the same cgroup namespaces "
"as the calling process.  This flag is intended for the implementation of "
"containers."
msgstr ""

#. type: Plain text
msgid "For further information on cgroup namespaces, see B<cgroup_namespaces>(7)."
msgstr ""

#. type: Plain text
msgid "Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWCGROUP>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 2.6.19)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_NEWIPC> is set, then create the process in a new IPC namespace.  "
"If this flag is not set, then (as with B<fork>(2)), the process is created "
"in the same IPC namespace as the calling process.  This flag is intended for "
"the implementation of containers."
msgstr ""

#.  commit 7eafd7c74c3f2e67c27621b987b28397110d643f
#.  https://lwn.net/Articles/312232/
#. type: Plain text
msgid ""
"An IPC namespace provides an isolated view of System\\ V IPC objects (see "
"B<svipc>(7))  and (since Linux 2.6.30)  POSIX message queues (see "
"B<mq_overview>(7)).  The common characteristic of these IPC mechanisms is "
"that IPC objects are identified by mechanisms other than filesystem "
"pathnames."
msgstr ""

#. type: Plain text
msgid ""
"Objects created in an IPC namespace are visible to all other processes that "
"are members of that namespace, but are not visible to processes in other IPC "
"namespaces."
msgstr ""

#. type: Plain text
msgid ""
"When an IPC namespace is destroyed (i.e., when the last process that is a "
"member of the namespace terminates), all IPC objects in the namespace are "
"automatically destroyed."
msgstr ""

#. type: Plain text
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWIPC>.  "
"This flag can't be specified in conjunction with B<CLONE_SYSVSEM>."
msgstr ""

#. type: Plain text
msgid "For further information on IPC namespaces, see B<namespaces>(7)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 2.6.24)"
msgstr ""

#. type: Plain text
msgid ""
"(The implementation of this flag was completed only by about kernel version "
"2.6.29.)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_NEWNET> is set, then create the process in a new network "
"namespace.  If this flag is not set, then (as with B<fork>(2))  the process "
"is created in the same network namespace as the calling process.  This flag "
"is intended for the implementation of containers."
msgstr ""

#.  FIXME . Add pointer to veth(4) page when it is eventually completed
#. type: Plain text
msgid ""
"A network namespace provides an isolated view of the networking stack "
"(network device interfaces, IPv4 and IPv6 protocol stacks, IP routing "
"tables, firewall rules, the I</proc/net> and I</sys/class/net> directory "
"trees, sockets, etc.).  A physical network device can live in exactly one "
"network namespace.  A virtual network device (\"veth\") pair provides a "
"pipe-like abstraction that can be used to create tunnels between network "
"namespaces, and can be used to create a bridge to a physical network device "
"in another namespace."
msgstr ""

#. type: Plain text
msgid ""
"When a network namespace is freed (i.e., when the last process in the "
"namespace terminates), its physical network devices are moved back to the "
"initial network namespace (not to the parent of the process).  For further "
"information on network namespaces, see B<namespaces>(7)."
msgstr ""

#. type: Plain text
msgid "Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWNET>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_NEWNS> (since Linux 2.4.19)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_NEWNS> is set, the cloned child is started in a new mount "
"namespace, initialized with a copy of the namespace of the parent.  If "
"B<CLONE_NEWNS> is not set, the child lives in the same mount namespace as "
"the parent."
msgstr ""

#.  See https://lwn.net/Articles/543273/
#. type: Plain text
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWNS>.  It "
"is not permitted to specify both B<CLONE_NEWNS> and B<CLONE_FS> in the same "
"B<clone>()  call."
msgstr ""

#. type: Plain text
msgid ""
"For further information on mount namespaces, see B<namespaces>(7)  and "
"B<mount_namespaces>(7)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 2.6.24)"
msgstr ""

#.  This explanation draws a lot of details from
#.  http://lwn.net/Articles/259217/
#.  Authors: Pavel Emelyanov <xemul@openvz.org>
#.  and Kir Kolyshkin <kir@openvz.org>
#
#.  The primary kernel commit is 30e49c263e36341b60b735cbef5ca37912549264
#.  Author: Pavel Emelyanov <xemul@openvz.org>
#. type: Plain text
msgid ""
"If B<CLONE_NEWPID> is set, then create the process in a new PID namespace.  "
"If this flag is not set, then (as with B<fork>(2))  the process is created "
"in the same PID namespace as the calling process.  This flag is intended for "
"the implementation of containers."
msgstr ""

#. type: Plain text
msgid ""
"For further information on PID namespaces, see B<namespaces>(7)  and "
"B<pid_namespaces>(7)."
msgstr ""

#. type: Plain text
msgid ""
"Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWPID>.  "
"This flag can't be specified in conjunction with B<CLONE_THREAD> or "
"B<CLONE_PARENT>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_NEWUSER>"
msgstr ""

#. type: Plain text
msgid ""
"(This flag first became meaningful for B<clone>()  in Linux 2.6.23, the "
"current B<clone>()  semantics were merged in Linux 3.5, and the final pieces "
"to make the user namespaces completely usable were merged in Linux 3.8.)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_NEWUSER> is set, then create the process in a new user "
"namespace.  If this flag is not set, then (as with B<fork>(2))  the process "
"is created in the same user namespace as the calling process."
msgstr ""

#. type: Plain text
msgid ""
"For further information on user namespaces, see B<namespaces>(7)  and "
"B<user_namespaces>(7)"
msgstr ""

#.  Before Linux 2.6.29, it appears that only CAP_SYS_ADMIN was needed
#. type: Plain text
msgid ""
"Before Linux 3.8, use of B<CLONE_NEWUSER> required that the caller have "
"three capabilities: B<CAP_SYS_ADMIN>, B<CAP_SETUID>, and B<CAP_SETGID>.  "
"Starting with Linux 3.8, no privileges are needed to create a user "
"namespace."
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#.  https://lwn.net/Articles/543273/
#.  The fix actually went into 3.9 and into 3.8.3. However, user namespaces
#.  were, for practical purposes, unusable in earlier 3.8.x because of the
#.  various filesystems that didn't support userns.
#. type: Plain text
msgid ""
"This flag can't be specified in conjunction with B<CLONE_THREAD> or "
"B<CLONE_PARENT>.  For security reasons, B<CLONE_NEWUSER> cannot be specified "
"in conjunction with B<CLONE_FS>."
msgstr ""

#. type: Plain text
msgid "For further information on user namespaces, see B<user_namespaces>(7)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 2.6.19)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_NEWUTS> is set, then create the process in a new UTS namespace, "
"whose identifiers are initialized by duplicating the identifiers from the "
"UTS namespace of the calling process.  If this flag is not set, then (as "
"with B<fork>(2))  the process is created in the same UTS namespace as the "
"calling process.  This flag is intended for the implementation of "
"containers."
msgstr ""

#. type: Plain text
msgid ""
"A UTS namespace is the set of identifiers returned by B<uname>(2); among "
"these, the domain name and the hostname can be modified by "
"B<setdomainname>(2)  and B<sethostname>(2), respectively.  Changes made to "
"the identifiers in a UTS namespace are visible to all other processes in the "
"same namespace, but are not visible to processes in other UTS namespaces."
msgstr ""

#. type: Plain text
msgid "Only a privileged process (B<CAP_SYS_ADMIN>)  can employ B<CLONE_NEWUTS>."
msgstr ""

#. type: Plain text
msgid "For further information on UTS namespaces, see B<namespaces>(7)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_PARENT> (since Linux 2.3.12)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_PARENT> is set, then the parent of the new child (as returned by "
"B<getppid>(2))  will be the same as that of the calling process."
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_PARENT> is not set, then (as with B<fork>(2))  the child's parent "
"is the calling process."
msgstr ""

#. type: Plain text
msgid ""
"Note that it is the parent process, as returned by B<getppid>(2), which is "
"signaled when the child terminates, so that if B<CLONE_PARENT> is set, then "
"the parent of the calling process, rather than the calling process itself, "
"will be signaled."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_PARENT_SETTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
msgid ""
"Store the child thread ID at the location I<ptid> in the parent's memory.  "
"(In Linux 2.5.32-2.5.48 there was a flag B<CLONE_SETTID> that did this.)  "
"The store operation completes before B<clone>()  returns control to user "
"space."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_PID> (obsolete)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_PID> is set, the child process is created with the same process "
"ID as the calling process.  This is good for hacking the system, but "
"otherwise of not much use.  Since 2.3.21 this flag can be specified only by "
"the system boot process (PID 0).  It disappeared in Linux 2.5.16.  Since "
"then, the kernel silently ignores it without error."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_PTRACE> (since Linux 2.2)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_PTRACE> is specified, and the calling process is being traced, "
"then trace the child also (see B<ptrace>(2))."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_SETTLS> (since Linux 2.5.32)"
msgstr ""

#. type: Plain text
msgid "The TLS (Thread Local Storage) descriptor is set to I<newtls.>"
msgstr ""

#. type: Plain text
msgid ""
"The interpretation of I<newtls> and the resulting effect is architecture "
"dependent.  On x86, I<newtls> is interpreted as a I<struct user_desc *> (See "
"B<set_thread_area>(2)).  On x86_64 it is the new value to be set for the %fs "
"base register (See the I<ARCH_SET_FS> argument to B<arch_prctl>(2)).  On "
"architectures with a dedicated TLS register, it is the new value of that "
"register."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_SIGHAND> (since Linux 2.0)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_SIGHAND> is set, the calling process and the child process share "
"the same table of signal handlers.  If the calling process or child process "
"calls B<sigaction>(2)  to change the behavior associated with a signal, the "
"behavior is changed in the other process as well.  However, the calling "
"process and child processes still have distinct signal masks and sets of "
"pending signals.  So, one of them may block or unblock some signals using "
"B<sigprocmask>(2)  without affecting the other process."
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_SIGHAND> is not set, the child process inherits a copy of the "
"signal handlers of the calling process at the time B<clone>()  is called.  "
"Calls to B<sigaction>(2)  performed later by one of the processes have no "
"effect on the other process."
msgstr ""

#. type: Plain text
msgid ""
"Since Linux 2.6.0-test6, I<flags> must also include B<CLONE_VM> if "
"B<CLONE_SIGHAND> is specified"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_STOPPED> (since Linux 2.6.0-test2)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_STOPPED> is set, then the child is initially stopped (as though "
"it was sent a B<SIGSTOP> signal), and must be resumed by sending it a "
"B<SIGCONT> signal."
msgstr ""

#.  glibc 2.8 removed this defn from bits/sched.h
#. type: Plain text
msgid ""
"This flag was I<deprecated> from Linux 2.6.25 onward, and was I<removed> "
"altogether in Linux 2.6.38.  Since then, the kernel silently ignores it "
"without error.  Starting with Linux 4.6, the same bit was reused for the "
"B<CLONE_NEWCGROUP> flag."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.5.10)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_SYSVSEM> is set, then the child and the calling process share a "
"single list of System V semaphore adjustment (I<semadj>)  values (see "
"B<semop>(2)).  In this case, the shared list accumulates I<semadj> values "
"across all processes sharing the list, and semaphore adjustments are "
"performed only when the last process that is sharing the list terminates (or "
"ceases sharing the list using B<unshare>(2)).  If this flag is not set, then "
"the child has a separate I<semadj> list that is initially empty."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_THREAD> (since Linux 2.4.0-test8)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_THREAD> is set, the child is placed in the same thread group as "
"the calling process.  To make the remainder of the discussion of "
"B<CLONE_THREAD> more readable, the term \"thread\" is used to refer to the "
"processes within a thread group."
msgstr ""

#. type: Plain text
msgid ""
"Thread groups were a feature added in Linux 2.4 to support the POSIX threads "
"notion of a set of threads that share a single PID.  Internally, this shared "
"PID is the so-called thread group identifier (TGID) for the thread group.  "
"Since Linux 2.4, calls to B<getpid>(2)  return the TGID of the caller."
msgstr ""

#. type: Plain text
msgid ""
"The threads within a group can be distinguished by their (system-wide)  "
"unique thread IDs (TID).  A new thread's TID is available as the function "
"result returned to the caller of B<clone>(), and a thread can obtain its own "
"TID using B<gettid>(2)."
msgstr ""

#. type: Plain text
msgid ""
"When a call is made to B<clone>()  without specifying B<CLONE_THREAD>, then "
"the resulting thread is placed in a new thread group whose TGID is the same "
"as the thread's TID.  This thread is the I<leader> of the new thread group."
msgstr ""

#. type: Plain text
msgid ""
"A new thread created with B<CLONE_THREAD> has the same parent process as the "
"caller of B<clone>()  (i.e., like B<CLONE_PARENT>), so that calls to "
"B<getppid>(2)  return the same value for all of the threads in a thread "
"group.  When a B<CLONE_THREAD> thread terminates, the thread that created it "
"using B<clone>()  is not sent a B<SIGCHLD> (or other termination) signal; "
"nor can the status of such a thread be obtained using B<wait>(2).  (The "
"thread is said to be I<detached>.)"
msgstr ""

#. type: Plain text
msgid ""
"After all of the threads in a thread group terminate the parent process of "
"the thread group is sent a B<SIGCHLD> (or other termination) signal."
msgstr ""

#. type: Plain text
msgid ""
"If any of the threads in a thread group performs an B<execve>(2), then all "
"threads other than the thread group leader are terminated, and the new "
"program is executed in the thread group leader."
msgstr ""

#. type: Plain text
msgid ""
"If one of the threads in a thread group creates a child using B<fork>(2), "
"then any thread in the group can B<wait>(2)  for that child."
msgstr ""

#. type: Plain text
msgid ""
"Since Linux 2.5.35, I<flags> must also include B<CLONE_SIGHAND> if "
"B<CLONE_THREAD> is specified (and note that, since Linux 2.6.0-test6, "
"B<CLONE_SIGHAND> also requires B<CLONE_VM> to be included)."
msgstr ""

#. type: Plain text
msgid ""
"Signals may be sent to a thread group as a whole (i.e., a TGID) using "
"B<kill>(2), or to a specific thread (i.e., TID) using B<tgkill>(2)."
msgstr ""

#. type: Plain text
msgid ""
"Signal dispositions and actions are process-wide: if an unhandled signal is "
"delivered to a thread, then it will affect (terminate, stop, continue, be "
"ignored in)  all members of the thread group."
msgstr ""

#. type: Plain text
msgid ""
"Each thread has its own signal mask, as set by B<sigprocmask>(2), but "
"signals can be pending either: for the whole process (i.e., deliverable to "
"any member of the thread group), when sent with B<kill>(2); or for an "
"individual thread, when sent with B<tgkill>(2).  A call to B<sigpending>(2)  "
"returns a signal set that is the union of the signals pending for the whole "
"process and the signals that are pending for the calling thread."
msgstr ""

#. type: Plain text
msgid ""
"If B<kill>(2)  is used to send a signal to a thread group, and the thread "
"group has installed a handler for the signal, then the handler will be "
"invoked in exactly one, arbitrarily selected member of the thread group that "
"has not blocked the signal.  If multiple threads in a group are waiting to "
"accept the same signal using B<sigwaitinfo>(2), the kernel will arbitrarily "
"select one of these threads to receive a signal sent using B<kill>(2)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_UNTRACED> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_UNTRACED> is specified, then a tracing process cannot force "
"B<CLONE_PTRACE> on this child process."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_VFORK> (since Linux 2.2)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_VFORK> is set, the execution of the calling process is suspended "
"until the child releases its virtual memory resources via a call to "
"B<execve>(2)  or B<_exit>(2)  (as with B<vfork>(2))."
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_VFORK> is not set, then both the calling process and the child "
"are schedulable after the call, and an application should not rely on "
"execution occurring in any particular order."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<CLONE_VM> (since Linux 2.0)"
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_VM> is set, the calling process and the child process run in the "
"same memory space.  In particular, memory writes performed by the calling "
"process or by the child process are also visible in the other process.  "
"Moreover, any memory mapping or unmapping performed with B<mmap>(2)  or "
"B<munmap>(2)  by the child or calling process also affects the other "
"process."
msgstr ""

#. type: Plain text
msgid ""
"If B<CLONE_VM> is not set, the child process runs in a separate copy of the "
"memory space of the calling process at the time of B<clone>().  Memory "
"writes or file mappings/unmappings performed by one of the processes do not "
"affect the other, as with B<fork>(2)."
msgstr ""

#. type: SS
#, no-wrap
msgid "C library/kernel differences"
msgstr ""

#. type: Plain text
msgid ""
"The raw B<clone>()  system call corresponds more closely to B<fork>(2)  in "
"that execution in the child continues from the point of the call.  As such, "
"the I<fn> and I<arg> arguments of the B<clone>()  wrapper function are "
"omitted.  Furthermore, the argument order changes.  In addition, there are "
"variations across architectures."
msgstr ""

#. type: Plain text
msgid ""
"The raw system call interface on x86-64 and some other architectures "
"(including sh, tile, and alpha) is roughly:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<child_stack>B<,>\n"
"B<           int *>I<ptid>B<, int *>I<ctid>B<,>\n"
"B<           unsigned long >I<newtls>B<);>\n"
msgstr ""

#.  CONFIG_CLONE_BACKWARDS
#. type: Plain text
msgid ""
"On x86-32, and several other common architectures (including score, ARM, ARM "
"64, PA-RISC, arc, Power PC, xtensa, and MIPS), the order of the last two "
"arguments is reversed:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<child_stack>B<,>\n"
"B<          int *>I<ptid>B<, unsigned long >I<newtls>B<,>\n"
"B<          int *>I<ctid>B<);>\n"
msgstr ""

#.  CONFIG_CLONE_BACKWARDS2
#. type: Plain text
msgid ""
"On the cris and s390 architectures, the order of the first two arguments is "
"reversed:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"B<long clone(void *>I<child_stack>B<, unsigned long >I<flags>B<,>\n"
"B<           int *>I<ptid>B<, int *>I<ctid>B<,>\n"
"B<           unsigned long >I<newtls>B<);>\n"
msgstr ""

#.  CONFIG_CLONE_BACKWARDS3
#. type: Plain text
msgid "On the microblaze architecture, an additional argument is supplied:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<child_stack>B<,>\n"
"B<           int >I<stack_size>B<,>         /* Size of stack */\n"
"B<           int *>I<ptid>B<, int *>I<ctid>B<,>\n"
"B<           unsigned long >I<newtls>B<);>\n"
msgstr ""

#. type: Plain text
msgid ""
"Another difference for the raw system call is that the I<child_stack> "
"argument may be zero, in which case copy-on-write semantics ensure that the "
"child gets separate copies of stack pages when either process modifies the "
"stack.  In this case, for correct operation, the B<CLONE_VM> option should "
"not be specified."
msgstr ""

#. type: SS
#, no-wrap
msgid "blackfin, m68k, and sparc"
msgstr ""

#.  Mike Frysinger noted in a 2013 mail:
#.      these arches don't define __ARCH_WANT_SYS_CLONE:
#.      blackfin ia64 m68k sparc
#. type: Plain text
msgid ""
"The argument-passing conventions on blackfin, m68k, and sparc are different "
"from the descriptions above.  For details, see the kernel (and glibc) "
"source."
msgstr ""

#. type: SS
#, no-wrap
msgid "ia64"
msgstr ""

#. type: Plain text
msgid "On ia64, a different interface is used:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"B<int __clone2(int (*>I<fn>B<)(void *), >\n"
"B<             void *>I<child_stack_base>B<, size_t >I<stack_size>B<,>\n"
"B<             int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t "
"*>I<ctid>B< */ );>\n"
msgstr ""

#. type: Plain text
msgid ""
"The prototype shown above is for the glibc wrapper function; the raw system "
"call interface has no I<fn> or I<arg> argument, and changes the order of the "
"arguments so that I<flags> is the first argument, and I<tls> is the last "
"argument."
msgstr ""

#. type: Plain text
msgid ""
"B<__clone2>()  operates in the same way as B<clone>(), except that "
"I<child_stack_base> points to the lowest address of the child's stack area, "
"and I<stack_size> specifies the size of the stack pointed to by "
"I<child_stack_base>."
msgstr ""

#. type: SS
#, no-wrap
msgid "Linux 2.4 and earlier"
msgstr ""

#. type: Plain text
msgid ""
"In Linux 2.4 and earlier, B<clone>()  does not take arguments I<ptid>, "
"I<tls>, and I<ctid>."
msgstr ""

#. type: SH
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#.  gettid(2) returns current->pid;
#.  getpid(2) returns current->tgid;
#. type: Plain text
msgid ""
"On success, the thread ID of the child process is returned in the caller's "
"thread of execution.  On failure, -1 is returned in the caller's context, no "
"child process will be created, and I<errno> will be set appropriately."
msgstr ""

#. type: SH
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
msgid "Too many processes are already running; see B<fork>(2)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
msgid ""
"B<CLONE_SIGHAND> was specified, but B<CLONE_VM> was not.  (Since Linux "
"2.6.0-test6.)"
msgstr ""

#.  .TP
#.  .B EINVAL
#.  Precisely one of
#.  .B CLONE_DETACHED
#.  and
#.  .B CLONE_THREAD
#.  was specified.
#.  (Since Linux 2.6.0-test6.)
#. type: Plain text
msgid ""
"B<CLONE_THREAD> was specified, but B<CLONE_SIGHAND> was not.  (Since Linux "
"2.5.35.)"
msgstr ""

#.  commit e66eded8309ebf679d3d3c1f5820d1f2ca332c71
#. type: Plain text
msgid "Both B<CLONE_FS> and B<CLONE_NEWNS> were specified in I<flags>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EINVAL> (since Linux 3.9)"
msgstr ""

#. type: Plain text
msgid "Both B<CLONE_NEWUSER> and B<CLONE_FS> were specified in I<flags>."
msgstr ""

#. type: Plain text
msgid "Both B<CLONE_NEWIPC> and B<CLONE_SYSVSEM> were specified in I<flags>."
msgstr ""

#. type: Plain text
msgid ""
"One (or both) of B<CLONE_NEWPID> or B<CLONE_NEWUSER> and one (or both) of "
"B<CLONE_THREAD> or B<CLONE_PARENT> were specified in I<flags>."
msgstr ""

#. type: Plain text
msgid ""
"Returned by the glibc B<clone>()  wrapper function when I<fn> or "
"I<child_stack> is specified as NULL."
msgstr ""

#. type: Plain text
msgid ""
"B<CLONE_NEWIPC> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_SYSVIPC> and B<CONFIG_IPC_NS> options."
msgstr ""

#. type: Plain text
msgid ""
"B<CLONE_NEWNET> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_NET_NS> option."
msgstr ""

#. type: Plain text
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_PID_NS> option."
msgstr ""

#. type: Plain text
msgid ""
"B<CLONE_NEWUTS> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_UTS> option."
msgstr ""

#. type: Plain text
msgid ""
"I<child_stack> is not aligned to a suitable boundary for this architecture.  "
"For example, on aarch64, I<child_stack> must be a multiple of 16."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
msgid ""
"Cannot allocate sufficient memory to allocate a task structure for the "
"child, or to copy those parts of the caller's context that need to be "
"copied."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOSPC> (since Linux 3.7)"
msgstr ""

#.  commit f2302505775fd13ba93f034206f1e2a587017929
#. type: Plain text
msgid ""
"B<CLONE_NEWPID> was specified in flags, but the limit on the nesting depth "
"of PID namespaces would have been exceeded; see B<pid_namespaces>(7)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOSPC> (since Linux 4.9; beforehand B<EUSERS>)"
msgstr ""

#. type: Plain text
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, and the call would cause the "
"limit on the number of nested user namespaces to be exceeded.  See "
"B<user_namespaces>(7)."
msgstr ""

#. type: Plain text
msgid ""
"From Linux 3.11 to Linux 4.8, the error diagnosed in this case was "
"B<EUSERS>."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ENOSPC> (since Linux 4.9)"
msgstr ""

#. type: Plain text
msgid ""
"One of the values in I<flags> specified the creation of a new user "
"namespace, but doing so would have caused the limit defined by the "
"corresponding file in I</proc/sys/user> to be exceeded.  For further "
"details, see B<namespaces>(7)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
msgid ""
"B<CLONE_NEWCGROUP>, B<CLONE_NEWIPC>, B<CLONE_NEWNET>, B<CLONE_NEWNS>, "
"B<CLONE_NEWPID>, or B<CLONE_NEWUTS> was specified by an unprivileged process "
"(process without B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: Plain text
msgid "B<CLONE_PID> was specified by a process other than process 0."
msgstr ""

#. type: Plain text
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, but either the effective user ID "
"or the effective group ID of the caller does not have a mapping in the "
"parent namespace (see B<user_namespaces>(7))."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EPERM> (since Linux 3.9)"
msgstr ""

#.  commit 3151527ee007b73a0ebd296010f1c0454a919c7d
#.  FIXME What is the rationale for this restriction?
#. type: Plain text
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags> and the caller is in a chroot "
"environment (i.e., the caller's root directory does not match the root "
"directory of the mount namespace in which it resides)."
msgstr ""

#. type: TP
#, no-wrap
msgid "B<ERESTARTNOINTR> (since Linux 2.6.17)"
msgstr ""

#.  commit 4a2c7a7837da1b91468e50426066d988050e4d56
#. type: Plain text
msgid ""
"System call was interrupted by a signal and will be restarted.  (This can be "
"seen only during a trace.)"
msgstr ""

#. type: TP
#, no-wrap
msgid "B<EUSERS> (Linux 3.11 to Linux 4.8)"
msgstr ""

#.  .SH VERSIONS
#.  There is no entry for
#.  .BR clone ()
#.  in libc5.
#.  glibc2 provides
#.  .BR clone ()
#.  as described in this manual page.
#. type: Plain text
msgid ""
"B<CLONE_NEWUSER> was specified in I<flags>, and the limit on the number of "
"nested user namespaces would be exceeded.  See the discussion of the "
"B<ENOSPC> error above."
msgstr ""

#. type: SH
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
msgid ""
"B<clone>()  is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: SH
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
msgid ""
"The B<kcmp>(2)  system call can be used to test whether two processes share "
"various resources such as a file descriptor table, System V semaphore undo "
"operations, or a virtual address space."
msgstr ""

#. type: Plain text
msgid ""
"Handlers registered using B<pthread_atfork>(3)  are not executed during a "
"call to B<clone>()."
msgstr ""

#. type: Plain text
msgid ""
"In the Linux 2.4.x series, B<CLONE_THREAD> generally does not make the "
"parent of the new thread the same as the parent of the calling process.  "
"However, for kernel versions 2.4.7 to 2.4.18 the B<CLONE_THREAD> flag "
"implied the B<CLONE_PARENT> flag (as in Linux 2.6.0 and later)."
msgstr ""

#. type: Plain text
msgid ""
"For a while there was B<CLONE_DETACHED> (introduced in 2.5.32): parent wants "
"no child-exit signal.  In Linux 2.6.2, the need to give this flag together "
"with B<CLONE_THREAD> disappeared.  This flag is still defined, but has no "
"effect."
msgstr ""

#. type: Plain text
msgid ""
"On i386, B<clone>()  should not be called through vsyscall, but directly "
"through I<int $0x80>."
msgstr ""

#. type: SH
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
msgid ""
"GNU C library versions 2.3.4 up to and including 2.24 contained a wrapper "
"function for B<getpid>(2)  that performed caching of PIDs.  This caching "
"relied on support in the glibc wrapper for B<clone>(), but limitations in "
"the implementation meant that the cache was not up to date in some "
"circumstances.  In particular, if a signal was delivered to the child "
"immediately after the B<clone>()  call, then a call to B<getpid>(2)  in a "
"handler for the signal could return the PID of the calling process (\"the "
"parent\"), if the clone wrapper had not yet had a chance to update the PID "
"cache in the child.  (This discussion ignores the case where the child was "
"created using B<CLONE_THREAD>, when B<getpid>(2)  I<should> return the same "
"value in the child and in the process that called B<clone>(), since the "
"caller and the child are in the same thread group.  The stale-cache problem "
"also does not occur if the I<flags> argument includes B<CLONE_VM>.)  To get "
"the truth, it was sometimes necessary to use code such as the following:"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    #include E<lt>syscall.hE<gt>\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    pid_t mypid;\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    mypid = syscall(SYS_getpid);\n"
msgstr ""

#. type: Plain text
msgid ""
"Because of the stale-cache problem, as well as other problems noted in "
"B<getpid>(2), the PID caching feature was removed in glibc 2.25."
msgstr ""

#. type: SH
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
msgid ""
"The following program demonstrates the use of B<clone>()  to create a child "
"process that executes in a separate UTS namespace.  The child changes the "
"hostname in its UTS namespace.  Both parent and child then display the "
"system hostname, making it possible to see that the hostname differs in the "
"UTS namespaces of the parent and child.  For an example of the use of this "
"program, see B<setns>(2)."
msgstr ""

#. type: SS
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/utsname.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"static int              /* Start function for cloned child */\n"
"childFunc(void *arg)\n"
"{\n"
"    struct utsname uts;\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    /* Change hostname in UTS namespace of child */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    if (sethostname(arg, strlen(arg)) == -1)\n"
"        errExit(\"sethostname\");\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    /* Retrieve and display hostname */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in child:  %s\\en\", uts.nodename);\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    /* Keep the namespace open for a while, by sleeping.\n"
"       This allows some experimentation--for example, another\n"
"       process might join the namespace. */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    sleep(200);\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    return 0;           /* Child terminates now */\n"
"}\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "#define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *stack;                    /* Start of stack buffer */\n"
"    char *stackTop;                 /* End of stack buffer */\n"
"    pid_t pid;\n"
"    struct utsname uts;\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>child-hostnameE<gt>\\en\", "
"argv[0]);\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    /* Allocate stack for child */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    stack = malloc(STACK_SIZE);\n"
"    if (stack == NULL)\n"
"        errExit(\"malloc\");\n"
"    stackTop = stack + STACK_SIZE;  /* Assume stack grows downward */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    /* Create child that has its own UTS namespace;\n"
"       child commences execution in childFunc() */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);\n"
"    if (pid == -1)\n"
"        errExit(\"clone\");\n"
"    printf(\"clone() returned %ld\\en\", (long) pid);\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    /* Parent falls through to here */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid "    sleep(1);           /* Give child time to change its hostname */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    /* Display hostname in parent\\(aqs UTS namespace. This will be\n"
"       different from hostname in child\\(aqs UTS namespace. */\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in parent: %s\\en\", uts.nodename);\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    if (waitpid(pid, NULL, 0) == -1)    /* Wait for child */\n"
"        errExit(\"waitpid\");\n"
"    printf(\"child has terminated\\en\");\n"
msgstr ""

#. type: Plain text
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SH
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
msgid ""
"B<fork>(2), B<futex>(2), B<getpid>(2), B<gettid>(2), B<kcmp>(2), "
"B<set_thread_area>(2), B<set_tid_address>(2), B<setns>(2), B<tkill>(2), "
"B<unshare>(2), B<wait>(2), B<capabilities>(7), B<namespaces>(7), "
"B<pthreads>(7)"
msgstr ""

#. type: SH
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
msgid ""
"This page is part of release 4.12 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%https://www.kernel.org/doc/man-pages/."
msgstr ""
