# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-10-03 15:49+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Dd
#: opensuse-leap-15-5
#, no-wrap
msgid "February 7, 2015"
msgstr ""

#. type: Dt
#: opensuse-leap-15-5
#, no-wrap
msgid "QUEUE 3"
msgstr ""

#. type: Sh
#: opensuse-leap-15-5
#, no-wrap
msgid "NAME"
msgstr ""

#.  .Nm SLIST_FOREACH_FROM ,
#.  .Nm SLIST_FOREACH_SAFE ,
#.  .Nm SLIST_FOREACH_FROM_SAFE ,
#.  .Nm SLIST_REMOVE_AFTER ,
#.  .Nm SLIST_SWAP ,
#.  .Nm STAILQ_FOREACH_FROM ,
#.  .Nm STAILQ_FOREACH_SAFE ,
#.  .Nm STAILQ_FOREACH_FROM_SAFE ,
#.  .Nm STAILQ_LAST ,
#.  .Nm STAILQ_REMOVE_AFTER ,
#.  .Nm STAILQ_SWAP ,
#.  .Nm LIST_FOREACH_FROM ,
#.  .Nm LIST_FOREACH_SAFE ,
#.  .Nm LIST_FOREACH_FROM_SAFE ,
#.  .Nm LIST_PREV ,
#.  .Nm LIST_SWAP ,
#.  .Nm TAILQ_FOREACH_FROM ,
#.  .Nm TAILQ_FOREACH_SAFE ,
#.  .Nm TAILQ_FOREACH_FROM_SAFE ,
#.  .Nm TAILQ_FOREACH_REVERSE_FROM ,
#.  .Nm TAILQ_FOREACH_REVERSE_SAFE ,
#.  .Nm TAILQ_FOREACH_REVERSE_FROM_SAFE ,
#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"E<.Nm SLIST_EMPTY>, E<.Nm SLIST_ENTRY>, E<.Nm SLIST_FIRST>, E<.Nm "
"SLIST_FOREACH>, E<.Nm SLIST_HEAD>, E<.Nm SLIST_HEAD_INITIALIZER>, E<.Nm "
"SLIST_INIT>, E<.Nm SLIST_INSERT_AFTER>, E<.Nm SLIST_INSERT_HEAD>, E<.Nm "
"SLIST_NEXT>, E<.Nm SLIST_REMOVE_HEAD>, E<.Nm SLIST_REMOVE>, E<.Nm "
"STAILQ_CONCAT>, E<.Nm STAILQ_EMPTY>, E<.Nm STAILQ_ENTRY>, E<.Nm "
"STAILQ_FIRST>, E<.Nm STAILQ_FOREACH>, E<.Nm STAILQ_HEAD>, E<.Nm "
"STAILQ_HEAD_INITIALIZER>, E<.Nm STAILQ_INIT>, E<.Nm STAILQ_INSERT_AFTER>, E<."
"Nm STAILQ_INSERT_HEAD>, E<.Nm STAILQ_INSERT_TAIL>, E<.Nm STAILQ_NEXT>, E<.Nm "
"STAILQ_REMOVE_HEAD>, E<.Nm STAILQ_REMOVE>, E<.Nm LIST_EMPTY>, E<.Nm "
"LIST_ENTRY>, E<.Nm LIST_FIRST>, E<.Nm LIST_FOREACH>, E<.Nm LIST_HEAD>, E<.Nm "
"LIST_HEAD_INITIALIZER>, E<.Nm LIST_INIT>, E<.Nm LIST_INSERT_AFTER>, E<.Nm "
"LIST_INSERT_BEFORE>, E<.Nm LIST_INSERT_HEAD>, E<.Nm LIST_NEXT>, E<.Nm "
"LIST_REMOVE>, E<.Nm TAILQ_CONCAT>, E<.Nm TAILQ_EMPTY>, E<.Nm TAILQ_ENTRY>, "
"E<.Nm TAILQ_FIRST>, E<.Nm TAILQ_FOREACH>, E<.Nm TAILQ_FOREACH_REVERSE>, E<."
"Nm TAILQ_HEAD>, E<.Nm TAILQ_HEAD_INITIALIZER>, E<.Nm TAILQ_INIT>, E<.Nm "
"TAILQ_INSERT_AFTER>, E<.Nm TAILQ_INSERT_BEFORE>, E<.Nm TAILQ_INSERT_HEAD>, "
"E<.Nm TAILQ_INSERT_TAIL>, E<.Nm TAILQ_LAST>, E<.Nm TAILQ_NEXT>, E<.Nm "
"TAILQ_PREV>, E<.Nm TAILQ_REMOVE>, E<.Nm TAILQ_SWAP>"
msgstr ""

#. type: Nd
#: opensuse-leap-15-5
#, no-wrap
msgid "implementations of singly-linked lists, singly-linked tail queues,"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "lists and tail queues"
msgstr ""

#. type: Sh
#: opensuse-leap-15-5
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: In
#: opensuse-leap-15-5
#, no-wrap
msgid "sys/queue.h"
msgstr ""

#
#
#
#
#.  .Fn SLIST_FOREACH_FROM "TYPE *var" "SLIST_HEAD *head" "SLIST_ENTRY NAME"
#.  .Fn SLIST_FOREACH_SAFE "TYPE *var" "SLIST_HEAD *head" "SLIST_ENTRY NAME" "TYPE *temp_var"
#.  .Fn SLIST_FOREACH_FROM_SAFE "TYPE *var" "SLIST_HEAD *head" "SLIST_ENTRY NAME" "TYPE *temp_var"
#.  .Fn SLIST_REMOVE_AFTER "TYPE *elm" "SLIST_ENTRY NAME"
#.  .Fn SLIST_SWAP "SLIST_HEAD *head1" "SLIST_HEAD *head2" "SLIST_ENTRY NAME"
#.  .Fn STAILQ_FOREACH_FROM "TYPE *var" "STAILQ_HEAD *head" "STAILQ_ENTRY NAME"
#.  .Fn STAILQ_FOREACH_SAFE "TYPE *var" "STAILQ_HEAD *head" "STAILQ_ENTRY NAME" "TYPE *temp_var"
#.  .Fn STAILQ_FOREACH_FROM_SAFE "TYPE *var" "STAILQ_HEAD *head" "STAILQ_ENTRY NAME" "TYPE *temp_var"
#.  .Fn STAILQ_LAST "STAILQ_HEAD *head" "TYPE" "STAILQ_ENTRY NAME"
#.  .Fn STAILQ_REMOVE_AFTER "STAILQ_HEAD *head" "TYPE *elm" "STAILQ_ENTRY NAME"
#.  .Fn STAILQ_SWAP "STAILQ_HEAD *head1" "STAILQ_HEAD *head2" "STAILQ_ENTRY NAME"
#.  .Fn LIST_FOREACH_FROM "TYPE *var" "LIST_HEAD *head" "LIST_ENTRY NAME"
#.  .Fn LIST_FOREACH_SAFE "TYPE *var" "LIST_HEAD *head" "LIST_ENTRY NAME" "TYPE *temp_var"
#.  .Fn LIST_FOREACH_FROM_SAFE "TYPE *var" "LIST_HEAD *head" "LIST_ENTRY NAME" "TYPE *temp_var"
#.  .Fn LIST_PREV "TYPE *elm" "LIST_HEAD *head" "TYPE" "LIST_ENTRY NAME"
#.  .Fn TAILQ_FOREACH_FROM "TYPE *var" "TAILQ_HEAD *head" "TAILQ_ENTRY NAME"
#.  .Fn TAILQ_FOREACH_SAFE "TYPE *var" "TAILQ_HEAD *head" "TAILQ_ENTRY NAME" "TYPE *temp_var"
#.  .Fn TAILQ_FOREACH_FROM_SAFE "TYPE *var" "TAILQ_HEAD *head" "TAILQ_ENTRY NAME" "TYPE *temp_var"
#.  .Fn TAILQ_FOREACH_REVERSE_FROM "TYPE *var" "TAILQ_HEAD *head" "HEADNAME" "TAILQ_ENTRY NAME"
#.  .Fn TAILQ_FOREACH_REVERSE_SAFE "TYPE *var" "TAILQ_HEAD *head" "HEADNAME" "TAILQ_ENTRY NAME" "TYPE *temp_var"
#.  .Fn TAILQ_FOREACH_REVERSE_FROM_SAFE "TYPE *var" "TAILQ_HEAD *head" "HEADNAME" "TAILQ_ENTRY NAME" "TYPE *temp_var"
#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"E<.Fn SLIST_EMPTY \"SLIST_HEAD *head\"> E<.Fn SLIST_ENTRY \"TYPE\"> E<.Fn "
"SLIST_FIRST \"SLIST_HEAD *head\"> E<.Fn SLIST_FOREACH \"TYPE *var\" "
"\"SLIST_HEAD *head\" \"SLIST_ENTRY NAME\"> E<.Fn SLIST_HEAD \"HEADNAME\" "
"\"TYPE\"> E<.Fn SLIST_HEAD_INITIALIZER \"SLIST_HEAD head\"> E<.Fn SLIST_INIT "
"\"SLIST_HEAD *head\"> E<.Fn SLIST_INSERT_AFTER \"TYPE *listelm\" \"TYPE "
"*elm\" \"SLIST_ENTRY NAME\"> E<.Fn SLIST_INSERT_HEAD \"SLIST_HEAD *head\" "
"\"TYPE *elm\" \"SLIST_ENTRY NAME\"> E<.Fn SLIST_NEXT \"TYPE *elm\" "
"\"SLIST_ENTRY NAME\"> E<.Fn SLIST_REMOVE_HEAD \"SLIST_HEAD *head\" "
"\"SLIST_ENTRY NAME\"> E<.Fn SLIST_REMOVE \"SLIST_HEAD *head\" \"TYPE *elm\" "
"\"TYPE\" \"SLIST_ENTRY NAME\"> E<.Fn STAILQ_CONCAT \"STAILQ_HEAD *head1\" "
"\"STAILQ_HEAD *head2\"> E<.Fn STAILQ_EMPTY \"STAILQ_HEAD *head\"> E<.Fn "
"STAILQ_ENTRY \"TYPE\"> E<.Fn STAILQ_FIRST \"STAILQ_HEAD *head\"> E<.Fn "
"STAILQ_FOREACH \"TYPE *var\" \"STAILQ_HEAD *head\" \"STAILQ_ENTRY NAME\"> E<."
"Fn STAILQ_HEAD \"HEADNAME\" \"TYPE\"> E<.Fn STAILQ_HEAD_INITIALIZER "
"\"STAILQ_HEAD head\"> E<.Fn STAILQ_INIT \"STAILQ_HEAD *head\"> E<.Fn "
"STAILQ_INSERT_AFTER \"STAILQ_HEAD *head\" \"TYPE *listelm\" \"TYPE *elm\" "
"\"STAILQ_ENTRY NAME\"> E<.Fn STAILQ_INSERT_HEAD \"STAILQ_HEAD *head\" \"TYPE "
"*elm\" \"STAILQ_ENTRY NAME\"> E<.Fn STAILQ_INSERT_TAIL \"STAILQ_HEAD *head\" "
"\"TYPE *elm\" \"STAILQ_ENTRY NAME\"> E<.Fn STAILQ_NEXT \"TYPE *elm\" "
"\"STAILQ_ENTRY NAME\"> E<.Fn STAILQ_REMOVE_HEAD \"STAILQ_HEAD *head\" "
"\"STAILQ_ENTRY NAME\"> E<.Fn STAILQ_REMOVE \"STAILQ_HEAD *head\" \"TYPE "
"*elm\" \"TYPE\" \"STAILQ_ENTRY NAME\"> E<.Fn LIST_EMPTY \"LIST_HEAD *head\"> "
"E<.Fn LIST_ENTRY \"TYPE\"> E<.Fn LIST_FIRST \"LIST_HEAD *head\"> E<.Fn "
"LIST_FOREACH \"TYPE *var\" \"LIST_HEAD *head\" \"LIST_ENTRY NAME\"> E<.Fn "
"LIST_HEAD \"HEADNAME\" \"TYPE\"> E<.Fn LIST_HEAD_INITIALIZER \"LIST_HEAD "
"head\"> E<.Fn LIST_INIT \"LIST_HEAD *head\"> E<.Fn LIST_INSERT_AFTER \"TYPE "
"*listelm\" \"TYPE *elm\" \"LIST_ENTRY NAME\"> E<.Fn LIST_INSERT_BEFORE "
"\"TYPE *listelm\" \"TYPE *elm\" \"LIST_ENTRY NAME\"> E<.Fn LIST_INSERT_HEAD "
"\"LIST_HEAD *head\" \"TYPE *elm\" \"LIST_ENTRY NAME\"> E<.Fn LIST_NEXT "
"\"TYPE *elm\" \"LIST_ENTRY NAME\"> E<.Fn LIST_REMOVE \"TYPE *elm\" "
"\"LIST_ENTRY NAME\"> E<.Fn LIST_SWAP \"LIST_HEAD *head1\" \"LIST_HEAD "
"*head2\" \"TYPE\" \"LIST_ENTRY NAME\"> E<.Fn TAILQ_CONCAT \"TAILQ_HEAD "
"*head1\" \"TAILQ_HEAD *head2\" \"TAILQ_ENTRY NAME\"> E<.Fn TAILQ_EMPTY "
"\"TAILQ_HEAD *head\"> E<.Fn TAILQ_ENTRY \"TYPE\"> E<.Fn TAILQ_FIRST "
"\"TAILQ_HEAD *head\"> E<.Fn TAILQ_FOREACH \"TYPE *var\" \"TAILQ_HEAD *head\" "
"\"TAILQ_ENTRY NAME\"> E<.Fn TAILQ_FOREACH_REVERSE \"TYPE *var\" \"TAILQ_HEAD "
"*head\" \"HEADNAME\" \"TAILQ_ENTRY NAME\"> E<.Fn TAILQ_HEAD \"HEADNAME\" "
"\"TYPE\"> E<.Fn TAILQ_HEAD_INITIALIZER \"TAILQ_HEAD head\"> E<.Fn TAILQ_INIT "
"\"TAILQ_HEAD *head\"> E<.Fn TAILQ_INSERT_AFTER \"TAILQ_HEAD *head\" \"TYPE "
"*listelm\" \"TYPE *elm\" \"TAILQ_ENTRY NAME\"> E<.Fn TAILQ_INSERT_BEFORE "
"\"TYPE *listelm\" \"TYPE *elm\" \"TAILQ_ENTRY NAME\"> E<.Fn "
"TAILQ_INSERT_HEAD \"TAILQ_HEAD *head\" \"TYPE *elm\" \"TAILQ_ENTRY NAME\"> "
"E<.Fn TAILQ_INSERT_TAIL \"TAILQ_HEAD *head\" \"TYPE *elm\" \"TAILQ_ENTRY "
"NAME\"> E<.Fn TAILQ_LAST \"TAILQ_HEAD *head\" \"HEADNAME\"> E<.Fn TAILQ_NEXT "
"\"TYPE *elm\" \"TAILQ_ENTRY NAME\"> E<.Fn TAILQ_PREV \"TYPE *elm\" "
"\"HEADNAME\" \"TAILQ_ENTRY NAME\"> E<.Fn TAILQ_REMOVE \"TAILQ_HEAD *head\" "
"\"TYPE *elm\" \"TAILQ_ENTRY NAME\"> E<.Fn TAILQ_SWAP \"TAILQ_HEAD *head1\" "
"\"TAILQ_HEAD *head2\" \"TYPE\" \"TAILQ_ENTRY NAME\">"
msgstr ""

#. type: Sh
#: opensuse-leap-15-5
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"These macros define and operate on four types of data structures: singly-"
"linked lists, singly-linked tail queues, lists, and tail queues.  All four "
"structures support the following functionality:"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "Insertion of a new entry at the head of the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "Insertion of a new entry after any element in the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "O(1) removal of an entry from the head of the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "Forward traversal through the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "Swapping the contents of two lists."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"Singly-linked lists are the simplest of the four data structures and support "
"only the above functionality.  Singly-linked lists are ideal for "
"applications with large datasets and few or no removals, or for implementing "
"a LIFO queue.  Singly-linked lists add the following functionality:"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "O(n) removal of any entry in the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "Singly-linked tail queues add the following functionality:"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "Entries can be added at the end of a list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "They may be concatenated."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "However:"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "All list insertions must specify the head of the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "Each head entry requires two pointers rather than one."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"Code size is about 15% greater and operations run about 20% slower than "
"singly-linked lists."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"Singly-linked tail queues are ideal for applications with large datasets and "
"few or no removals, or for implementing a FIFO queue."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"All doubly linked types of data structures (lists and tail queues)  "
"additionally allow:"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "Insertion of a new entry before any element in the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "O(1) removal of any entry in the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "Each element requires two pointers rather than one."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"Code size and execution time of operations (except for removal) is about "
"twice that of the singly-linked data-structures."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"Linked lists are the simplest of the doubly linked data structures.  They "
"add the following functionality over the above:"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "They may be traversed backwards."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"To traverse backwards, an entry to begin the traversal and the list in which "
"it is contained must be specified."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "Tail queues add the following functionality:"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "They may be traversed backwards, from tail to head."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "All list insertions and removals must specify the head of the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"In the macro definitions, E<.Fa TYPE> is the name of a user defined "
"structure, that must contain a field of type E<.Li SLIST_ENTRY>, E<.Li "
"STAILQ_ENTRY>, E<.Li LIST_ENTRY>, or E<.Li TAILQ_ENTRY>, named E<.Fa NAME>.  "
"The argument E<.Fa HEADNAME> is the name of a user defined structure that "
"must be declared using the macros E<.Li SLIST_HEAD>, E<.Li STAILQ_HEAD>, E<."
"Li LIST_HEAD>, or E<.Li TAILQ_HEAD>.  See the examples below for further "
"explanation of how these macros are used."
msgstr ""

#. type: Ss
#: opensuse-leap-15-5
#, no-wrap
msgid "Singly-linked lists"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"A singly-linked list is headed by a structure defined by the E<.Nm "
"SLIST_HEAD> macro.  This structure contains a single pointer to the first "
"element on the list.  The elements are singly linked for minimum space and "
"pointer manipulation overhead at the expense of O(n) removal for arbitrary "
"elements.  New elements can be added to the list after an existing element "
"or at the head of the list.  An E<.Fa SLIST_HEAD> structure is declared as "
"follows:"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid "SLIST_HEAD(HEADNAME, TYPE) head;\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"where E<.Fa HEADNAME> is the name of the structure to be defined, and E<.Fa "
"TYPE> is the type of the elements to be linked into the list.  A pointer to "
"the head of the list can later be declared as:"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid "struct HEADNAME *headp;\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid "(The names E<.Li head> and E<.Li headp> are user selectable.)"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm SLIST_HEAD_INITIALIZER> evaluates to an initializer for the "
"list E<.Fa head>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm SLIST_EMPTY> evaluates to true if there are no elements in "
"the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm SLIST_ENTRY> declares a structure that connects the elements "
"in the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm SLIST_FIRST> returns the first element in the list or NULL "
"if the list is empty."
msgstr ""

#.  .Pp
#.  The macro
#.  .Nm SLIST_FOREACH_FROM
#.  behaves identically to
#.  .Nm SLIST_FOREACH
#.  when
#.  .Fa var
#.  is NULL, else it treats
#.  .Fa var
#.  as a previously found SLIST element and begins the loop at
#.  .Fa var
#.  instead of the first element in the SLIST referenced by
#.  .Fa head .
#.  .Pp
#.  The macro
#.  .Nm SLIST_FOREACH_SAFE
#.  traverses the list referenced by
#.  .Fa head
#.  in the forward direction, assigning each element in
#.  turn to
#.  .Fa var .
#.  However, unlike
#.  .Fn SLIST_FOREACH
#.  here it is permitted to both remove
#.  .Fa var
#.  as well as free it from within the loop safely without interfering with the
#.  traversal.
#.  .Pp
#.  The macro
#.  .Nm SLIST_FOREACH_FROM_SAFE
#.  behaves identically to
#.  .Nm SLIST_FOREACH_SAFE
#.  when
#.  .Fa var
#.  is NULL, else it treats
#.  .Fa var
#.  as a previously found SLIST element and begins the loop at
#.  .Fa var
#.  instead of the first element in the SLIST referenced by
#.  .Fa head .
#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm SLIST_FOREACH> traverses the list referenced by E<.Fa head> "
"in the forward direction, assigning each element in turn to E<.Fa var>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm SLIST_INIT> initializes the list referenced by E<.Fa head>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm SLIST_INSERT_HEAD> inserts the new element E<.Fa elm> at the "
"head of the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm SLIST_INSERT_AFTER> inserts the new element E<.Fa elm> after "
"the element E<.Fa listelm>."
msgstr ""

#.  .Pp
#.  The macro
#.  .Nm SLIST_REMOVE_AFTER
#.  removes the element after
#.  .Fa elm
#.  from the list.
#.  Unlike
#.  .Fa SLIST_REMOVE ,
#.  this macro does not traverse the entire list.
#. type: Plain text
#: opensuse-leap-15-5
msgid "The macro E<.Nm SLIST_NEXT> returns the next element in the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm SLIST_REMOVE_HEAD> removes the element E<.Fa elm> from the "
"head of the list.  For optimum efficiency, elements being removed from the "
"head of the list should explicitly use this macro instead of the generic E<."
"Fa SLIST_REMOVE> macro."
msgstr ""

#.  .Pp
#.  The macro
#.  .Nm SLIST_SWAP
#.  swaps the contents of
#.  .Fa head1
#.  and
#.  .Fa head2 .
#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm SLIST_REMOVE> removes the element E<.Fa elm> from the list."
msgstr ""

#. type: Ss
#: opensuse-leap-15-5
#, no-wrap
msgid "Singly-linked list example"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"SLIST_HEAD(slisthead, entry) head =\n"
"    SLIST_HEAD_INITIALIZER(head);\n"
"struct slisthead *headp;\t\t/* Singly-linked List\n"
"                                           head. */\n"
"struct entry {\n"
"\t...\n"
"\tSLIST_ENTRY(entry) entries;\t/* Singly-linked List. */\n"
"\t...\n"
"} *n1, *n2, *n3, *np;\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid "SLIST_INIT(&head);\t\t\t/* Initialize the list. */\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));\t/* Insert at the head. */\n"
"SLIST_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"n2 = malloc(sizeof(struct entry));\t/* Insert after. */\n"
"SLIST_INSERT_AFTER(n1, n2, entries);\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"SLIST_REMOVE(&head, n2, entry, entries);/* Deletion. */\n"
"free(n2);\n"
msgstr ""

#. 					/* Safe forward traversal. */
#. SLIST_FOREACH_SAFE(np, &head, entries, np_temp) {
#. 	np\->do_stuff();
#. 	...
#. 	SLIST_REMOVE(&head, np, entry, entries);
#. 	free(np);
#. }
#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"n3 = SLIST_FIRST(&head);\n"
"SLIST_REMOVE_HEAD(&head, entries);\t/* Deletion from the head. */\n"
"free(n3);\n"
"\t\t\t\t\t/* Forward traversal. */\n"
"SLIST_FOREACH(np, &head, entries)\n"
"\tnp\\-E<gt> ...\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"while (!SLIST_EMPTY(&head)) {\t\t/* List Deletion. */\n"
"\tn1 = SLIST_FIRST(&head);\n"
"\tSLIST_REMOVE_HEAD(&head, entries);\n"
"\tfree(n1);\n"
"}\n"
msgstr ""

#. type: Ss
#: opensuse-leap-15-5
#, no-wrap
msgid "Singly-linked tail queues"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"A singly-linked tail queue is headed by a structure defined by the E<.Nm "
"STAILQ_HEAD> macro.  This structure contains a pair of pointers, one to the "
"first element in the tail queue and the other to the last element in the "
"tail queue.  The elements are singly linked for minimum space and pointer "
"manipulation overhead at the expense of O(n) removal for arbitrary "
"elements.  New elements can be added to the tail queue after an existing "
"element, at the head of the tail queue, or at the end of the tail queue.  A "
"E<.Fa STAILQ_HEAD> structure is declared as follows:"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid "STAILQ_HEAD(HEADNAME, TYPE) head;\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"where E<.Li HEADNAME> is the name of the structure to be defined, and E<.Li "
"TYPE> is the type of the elements to be linked into the tail queue.  A "
"pointer to the head of the tail queue can later be declared as:"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm STAILQ_HEAD_INITIALIZER> evaluates to an initializer for the "
"tail queue E<.Fa head>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm STAILQ_CONCAT> concatenates the tail queue headed by E<.Fa "
"head2> onto the end of the one headed by E<.Fa head1> removing all entries "
"from the former."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm STAILQ_EMPTY> evaluates to true if there are no items on the "
"tail queue."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm STAILQ_ENTRY> declares a structure that connects the "
"elements in the tail queue."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm STAILQ_FIRST> returns the first item on the tail queue or "
"NULL if the tail queue is empty."
msgstr ""

#.  .Pp
#.  The macro
#.  .Nm STAILQ_FOREACH_FROM
#.  behaves identically to
#.  .Nm STAILQ_FOREACH
#.  when
#.  .Fa var
#.  is NULL, else it treats
#.  .Fa var
#.  as a previously found STAILQ element and begins the loop at
#.  .Fa var
#.  instead of the first element in the STAILQ referenced by
#.  .Fa head .
#.  .Pp
#.  The macro
#.  .Nm STAILQ_FOREACH_SAFE
#.  traverses the tail queue referenced by
#.  .Fa head
#.  in the forward direction, assigning each element
#.  in turn to
#.  .Fa var .
#.  However, unlike
#.  .Fn STAILQ_FOREACH
#.  here it is permitted to both remove
#.  .Fa var
#.  as well as free it from within the loop safely without interfering with the
#.  traversal.
#.  .Pp
#.  The macro
#.  .Nm STAILQ_FOREACH_FROM_SAFE
#.  behaves identically to
#.  .Nm STAILQ_FOREACH_SAFE
#.  when
#.  .Fa var
#.  is NULL, else it treats
#.  .Fa var
#.  as a previously found STAILQ element and begins the loop at
#.  .Fa var
#.  instead of the first element in the STAILQ referenced by
#.  .Fa head .
#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm STAILQ_FOREACH> traverses the tail queue referenced by E<.Fa "
"head> in the forward direction, assigning each element in turn to E<.Fa var>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm STAILQ_INIT> initializes the tail queue referenced by E<.Fa "
"head>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm STAILQ_INSERT_HEAD> inserts the new element E<.Fa elm> at "
"the head of the tail queue."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm STAILQ_INSERT_TAIL> inserts the new element E<.Fa elm> at "
"the end of the tail queue."
msgstr ""

#.  .Pp
#.  The macro
#.  .Nm STAILQ_LAST
#.  returns the last item on the tail queue.
#.  If the tail queue is empty the return value is
#.  .Dv NULL .
#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm STAILQ_INSERT_AFTER> inserts the new element E<.Fa elm> "
"after the element E<.Fa listelm>."
msgstr ""

#.  .Pp
#.  The macro
#.  .Nm STAILQ_REMOVE_AFTER
#.  removes the element after
#.  .Fa elm
#.  from the tail queue.
#.  Unlike
#.  .Fa STAILQ_REMOVE ,
#.  this macro does not traverse the entire tail queue.
#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm STAILQ_NEXT> returns the next item on the tail queue, or "
"NULL this item is the last."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm STAILQ_REMOVE_HEAD> removes the element at the head of the "
"tail queue.  For optimum efficiency, elements being removed from the head of "
"the tail queue should use this macro explicitly rather than the generic E<."
"Fa STAILQ_REMOVE> macro."
msgstr ""

#.  .Pp
#.  The macro
#.  .Nm STAILQ_SWAP
#.  swaps the contents of
#.  .Fa head1
#.  and
#.  .Fa head2 .
#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm STAILQ_REMOVE> removes the element E<.Fa elm> from the tail "
"queue."
msgstr ""

#. type: Ss
#: opensuse-leap-15-5
#, no-wrap
msgid "Singly-linked tail queue example"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"STAILQ_HEAD(stailhead, entry) head =\n"
"    STAILQ_HEAD_INITIALIZER(head);\n"
"struct stailhead *headp;\t\t/* Singly-linked tail queue head. */\n"
"struct entry {\n"
"\t...\n"
"\tSTAILQ_ENTRY(entry) entries;\t/* Tail queue. */\n"
"\t...\n"
"} *n1, *n2, *n3, *np;\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid "STAILQ_INIT(&head);\t\t\t/* Initialize the queue. */\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));\t/* Insert at the head. */\n"
"STAILQ_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));\t/* Insert at the tail. */\n"
"STAILQ_INSERT_TAIL(&head, n1, entries);\n"
msgstr ""

#. 					/* Safe forward traversal. */
#. STAILQ_FOREACH_SAFE(np, &head, entries, np_temp) {
#. 	np\->do_stuff();
#. 	...
#. 	STAILQ_REMOVE(&head, np, entry, entries);
#. 	free(np);
#. }
#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"n2 = malloc(sizeof(struct entry));\t/* Insert after. */\n"
"STAILQ_INSERT_AFTER(&head, n1, n2, entries);\n"
"\t\t\t\t\t/* Deletion. */\n"
"STAILQ_REMOVE(&head, n2, entry, entries);\n"
"free(n2);\n"
"\t\t\t\t\t/* Deletion from the head. */\n"
"n3 = STAILQ_FIRST(&head);\n"
"STAILQ_REMOVE_HEAD(&head, entries);\n"
"free(n3);\n"
"\t\t\t\t\t/* Forward traversal. */\n"
"STAILQ_FOREACH(np, &head, entries)\n"
"\tnp\\-E<gt> ...\n"
"\t\t\t\t\t/* TailQ Deletion. */\n"
"while (!STAILQ_EMPTY(&head)) {\n"
"\tn1 = STAILQ_FIRST(&head);\n"
"\tSTAILQ_REMOVE_HEAD(&head, entries);\n"
"\tfree(n1);\n"
"}\n"
"\t\t\t\t\t/* Faster TailQ Deletion. */\n"
"n1 = STAILQ_FIRST(&head);\n"
"while (n1 != NULL) {\n"
"\tn2 = STAILQ_NEXT(n1, entries);\n"
"\tfree(n1);\n"
"\tn1 = n2;\n"
"}\n"
"STAILQ_INIT(&head);\n"
msgstr ""

#. type: Ss
#: opensuse-leap-15-5
#, no-wrap
msgid "Lists"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"A list is headed by a structure defined by the E<.Nm LIST_HEAD> macro.  This "
"structure contains a single pointer to the first element on the list.  The "
"elements are doubly linked so that an arbitrary element can be removed "
"without traversing the list.  New elements can be added to the list after an "
"existing element, before an existing element, or at the head of the list.  A "
"E<.Fa LIST_HEAD> structure is declared as follows:"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid "LIST_HEAD(HEADNAME, TYPE) head;\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm LIST_HEAD_INITIALIZER> evaluates to an initializer for the "
"list E<.Fa head>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm LIST_EMPTY> evaluates to true if there are no elements in "
"the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm LIST_ENTRY> declares a structure that connects the elements "
"in the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm LIST_FIRST> returns the first element in the list or NULL if "
"the list is empty."
msgstr ""

#.  .Pp
#.  The macro
#.  .Nm LIST_FOREACH_FROM
#.  behaves identically to
#.  .Nm LIST_FOREACH
#.  when
#.  .Fa var
#.  is NULL, else it treats
#.  .Fa var
#.  as a previously found LIST element and begins the loop at
#.  .Fa var
#.  instead of the first element in the LIST referenced by
#.  .Fa head .
#.  .Pp
#.  The macro
#.  .Nm LIST_FOREACH_SAFE
#.  traverses the list referenced by
#.  .Fa head
#.  in the forward direction, assigning each element in turn to
#.  .Fa var .
#.  However, unlike
#.  .Fn LIST_FOREACH
#.  here it is permitted to both remove
#.  .Fa var
#.  as well as free it from within the loop safely without interfering with the
#.  traversal.
#.  .Pp
#.  The macro
#.  .Nm LIST_FOREACH_FROM_SAFE
#.  behaves identically to
#.  .Nm LIST_FOREACH_SAFE
#.  when
#.  .Fa var
#.  is NULL, else it treats
#.  .Fa var
#.  as a previously found LIST element and begins the loop at
#.  .Fa var
#.  instead of the first element in the LIST referenced by
#.  .Fa head .
#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm LIST_FOREACH> traverses the list referenced by E<.Fa head> "
"in the forward direction, assigning each element in turn to E<.Fa var>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm LIST_INIT> initializes the list referenced by E<.Fa head>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm LIST_INSERT_HEAD> inserts the new element E<.Fa elm> at the "
"head of the list."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm LIST_INSERT_AFTER> inserts the new element E<.Fa elm> after "
"the element E<.Fa listelm>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm LIST_INSERT_BEFORE> inserts the new element E<.Fa elm> "
"before the element E<.Fa listelm>."
msgstr ""

#.  .Pp
#.  The macro
#.  .Nm LIST_PREV
#.  returns the previous element in the list, or NULL if this is the first.
#.  List
#.  .Fa head
#.  must contain element
#.  .Fa elm .
#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm LIST_NEXT> returns the next element in the list, or NULL if "
"this is the last."
msgstr ""

#.  .Pp
#.  The macro
#.  .Nm LIST_SWAP
#.  swaps the contents of
#.  .Fa head1
#.  and
#.  .Fa head2 .
#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm LIST_REMOVE> removes the element E<.Fa elm> from the list."
msgstr ""

#. type: Ss
#: opensuse-leap-15-5
#, no-wrap
msgid "List example"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"LIST_HEAD(listhead, entry) head =\n"
"    LIST_HEAD_INITIALIZER(head);\n"
"struct listhead *headp;\t\t\t/* List head. */\n"
"struct entry {\n"
"\t...\n"
"\tLIST_ENTRY(entry) entries;\t/* List. */\n"
"\t...\n"
"} *n1, *n2, *n3, *np, *np_temp;\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid "LIST_INIT(&head);\t\t\t/* Initialize the list. */\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));\t/* Insert at the head. */\n"
"LIST_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"n2 = malloc(sizeof(struct entry));\t/* Insert after. */\n"
"LIST_INSERT_AFTER(n1, n2, entries);\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"n3 = malloc(sizeof(struct entry));\t/* Insert before. */\n"
"LIST_INSERT_BEFORE(n2, n3, entries);\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"LIST_REMOVE(n2, entries);\t\t/* Deletion. */\n"
"free(n2);\n"
"\t\t\t\t\t/* Forward traversal. */\n"
"LIST_FOREACH(np, &head, entries)\n"
"\tnp\\-E<gt> ...\n"
msgstr ""

#.  					/* Safe forward traversal. */
#.  LIST_FOREACH_SAFE(np, &head, entries, np_temp) {
#.  	np\->do_stuff();
#.  	...
#.  	LIST_REMOVE(np, entries);
#.  	free(np);
#.  }
#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"while (!LIST_EMPTY(&head)) {\t\t/* List Deletion. */\n"
"\tn1 = LIST_FIRST(&head);\n"
"\tLIST_REMOVE(n1, entries);\n"
"\tfree(n1);\n"
"}\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"n1 = LIST_FIRST(&head);\t\t\t/* Faster List Deletion. */\n"
"while (n1 != NULL) {\n"
"\tn2 = LIST_NEXT(n1, entries);\n"
"\tfree(n1);\n"
"\tn1 = n2;\n"
"}\n"
"LIST_INIT(&head);\n"
msgstr ""

#. type: Ss
#: opensuse-leap-15-5
#, no-wrap
msgid "Tail queues"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"A tail queue is headed by a structure defined by the E<.Nm TAILQ_HEAD> "
"macro.  This structure contains a pair of pointers, one to the first element "
"in the tail queue and the other to the last element in the tail queue.  The "
"elements are doubly linked so that an arbitrary element can be removed "
"without traversing the tail queue.  New elements can be added to the tail "
"queue after an existing element, before an existing element, at the head of "
"the tail queue, or at the end of the tail queue.  A E<.Fa TAILQ_HEAD> "
"structure is declared as follows:"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid "TAILQ_HEAD(HEADNAME, TYPE) head;\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_HEAD_INITIALIZER> evaluates to an initializer for the "
"tail queue E<.Fa head>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_CONCAT> concatenates the tail queue headed by E<.Fa "
"head2> onto the end of the one headed by E<.Fa head1> removing all entries "
"from the former."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_EMPTY> evaluates to true if there are no items on the "
"tail queue."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_ENTRY> declares a structure that connects the elements "
"in the tail queue."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_FIRST> returns the first item on the tail queue or "
"NULL if the tail queue is empty."
msgstr ""

#.  .Pp
#.  The macro
#.  .Nm TAILQ_FOREACH_FROM
#.  behaves identically to
#.  .Nm TAILQ_FOREACH
#.  when
#.  .Fa var
#.  is NULL, else it treats
#.  .Fa var
#.  as a previously found TAILQ element and begins the loop at
#.  .Fa var
#.  instead of the first element in the TAILQ referenced by
#.  .Fa head .
#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_FOREACH> traverses the tail queue referenced by E<.Fa "
"head> in the forward direction, assigning each element in turn to E<.Fa "
"var>.  E<.Fa var> is set to E<.Dv NULL> if the loop completes normally, or "
"if there were no elements."
msgstr ""

#.  .Pp
#.  The macro
#.  .Nm TAILQ_FOREACH_REVERSE_FROM
#.  behaves identically to
#.  .Nm TAILQ_FOREACH_REVERSE
#.  when
#.  .Fa var
#.  is NULL, else it treats
#.  .Fa var
#.  as a previously found TAILQ element and begins the reverse loop at
#.  .Fa var
#.  instead of the last element in the TAILQ referenced by
#.  .Fa head .
#.  .Pp
#.  The macros
#.  .Nm TAILQ_FOREACH_SAFE
#.  and
#.  .Nm TAILQ_FOREACH_REVERSE_SAFE
#.  traverse the list referenced by
#.  .Fa head
#.  in the forward or reverse direction respectively,
#.  assigning each element in turn to
#.  .Fa var .
#.  However, unlike their unsafe counterparts,
#.  .Nm TAILQ_FOREACH
#.  and
#.  .Nm TAILQ_FOREACH_REVERSE
#.  permit to both remove
#.  .Fa var
#.  as well as free it from within the loop safely without interfering with the
#.  traversal.
#.  .Pp
#.  The macro
#.  .Nm TAILQ_FOREACH_FROM_SAFE
#.  behaves identically to
#.  .Nm TAILQ_FOREACH_SAFE
#.  when
#.  .Fa var
#.  is NULL, else it treats
#.  .Fa var
#.  as a previously found TAILQ element and begins the loop at
#.  .Fa var
#.  instead of the first element in the TAILQ referenced by
#.  .Fa head .
#.  .Pp
#.  The macro
#.  .Nm TAILQ_FOREACH_REVERSE_FROM_SAFE
#.  behaves identically to
#.  .Nm TAILQ_FOREACH_REVERSE_SAFE
#.  when
#.  .Fa var
#.  is NULL, else it treats
#.  .Fa var
#.  as a previously found TAILQ element and begins the reverse loop at
#.  .Fa var
#.  instead of the last element in the TAILQ referenced by
#.  .Fa head .
#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_FOREACH_REVERSE> traverses the tail queue referenced "
"by E<.Fa head> in the reverse direction, assigning each element in turn to "
"E<.Fa var>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_INIT> initializes the tail queue referenced by E<.Fa "
"head>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_INSERT_HEAD> inserts the new element E<.Fa elm> at the "
"head of the tail queue."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_INSERT_TAIL> inserts the new element E<.Fa elm> at the "
"end of the tail queue."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_INSERT_AFTER> inserts the new element E<.Fa elm> after "
"the element E<.Fa listelm>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_INSERT_BEFORE> inserts the new element E<.Fa elm> "
"before the element E<.Fa listelm>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_LAST> returns the last item on the tail queue.  If the "
"tail queue is empty the return value is E<.Dv NULL>."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_NEXT> returns the next item on the tail queue, or NULL "
"if this item is the last."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_PREV> returns the previous item on the tail queue, or "
"NULL if this item is the first."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_REMOVE> removes the element E<.Fa elm> from the tail "
"queue."
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"The macro E<.Nm TAILQ_SWAP> swaps the contents of E<.Fa head1> and E<.Fa "
"head2>."
msgstr ""

#. type: Ss
#: opensuse-leap-15-5
#, no-wrap
msgid "Tail queue example"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"TAILQ_HEAD(tailhead, entry) head =\n"
"    TAILQ_HEAD_INITIALIZER(head);\n"
"struct tailhead *headp;\t\t\t/* Tail queue head. */\n"
"struct entry {\n"
"\t...\n"
"\tTAILQ_ENTRY(entry) entries;\t/* Tail queue. */\n"
"\t...\n"
"} *n1, *n2, *n3, *np;\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid "TAILQ_INIT(&head);\t\t\t/* Initialize the queue. */\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));\t/* Insert at the head. */\n"
"TAILQ_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));\t/* Insert at the tail. */\n"
"TAILQ_INSERT_TAIL(&head, n1, entries);\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"n2 = malloc(sizeof(struct entry));\t/* Insert after. */\n"
"TAILQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"n3 = malloc(sizeof(struct entry));\t/* Insert before. */\n"
"TAILQ_INSERT_BEFORE(n2, n3, entries);\n"
msgstr ""

#.  					/* Safe forward traversal. */
#.  TAILQ_FOREACH_SAFE(np, &head, entries, np_temp) {
#.  	np\->do_stuff();
#.  	...
#.  	TAILQ_REMOVE(&head, np, entries);
#.  	free(np);
#.  }
#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"TAILQ_REMOVE(&head, n2, entries);\t/* Deletion. */\n"
"free(n2);\n"
"\t\t\t\t\t/* Forward traversal. */\n"
"TAILQ_FOREACH(np, &head, entries)\n"
"\tnp\\-E<gt> ...\n"
"\t\t\t\t\t/* Reverse traversal. */\n"
"TAILQ_FOREACH_REVERSE(np, &head, tailhead, entries)\n"
"\tnp\\-E<gt> ...\n"
"\t\t\t\t\t/* TailQ Deletion. */\n"
"while (!TAILQ_EMPTY(&head)) {\n"
"\tn1 = TAILQ_FIRST(&head);\n"
"\tTAILQ_REMOVE(&head, n1, entries);\n"
"\tfree(n1);\n"
"}\n"
"\t\t\t\t\t/* Faster TailQ Deletion. */\n"
"n1 = TAILQ_FIRST(&head);\n"
"while (n1 != NULL) {\n"
"\tn2 = TAILQ_NEXT(n1, entries);\n"
"\tfree(n1);\n"
"\tn1 = n2;\n"
"}\n"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
#, no-wrap
msgid ""
"TAILQ_INIT(&head);\n"
"n2 = malloc(sizeof(struct entry));  /* Insert before. */\n"
"CIRCLEQ_INSERT_BEFORE(&head, n1, n2, entries);\n"
"                                    /* Forward traversal. */\n"
"for (np = head.cqh_first; np != (void *)&head;\n"
"        np = np\\-E<gt>entries.cqe_next)\n"
"    np\\-E<gt> ...\n"
"                                    /* Reverse traversal. */\n"
"for (np = head.cqh_last; np != (void *)&head; np = np\\-E<gt>entries.cqe_prev)\n"
"    np\\-E<gt> ...\n"
"                                    /* Delete. */\n"
"while (head.cqh_first != (void *)&head)\n"
"    CIRCLEQ_REMOVE(&head, head.cqh_first, entries);\n"
msgstr ""

#. type: Sh
#: opensuse-leap-15-5
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"Not in POSIX.1, POSIX.1-2001 or POSIX.1-2008.  Present on the BSDs.  E<.Nm "
"queue> functions first appeared in E<.Bx 4.4>."
msgstr ""

#. type: Sh
#: opensuse-leap-15-5
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#.  .Xr tree 3
#. type: Plain text
#: opensuse-leap-15-5
msgid "E<.Xr insque 3>"
msgstr ""

#. type: Sh
#: opensuse-leap-15-5
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: opensuse-leap-15-5
msgid ""
"This page is part of release 4.16 of the Linux E<.Em man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at \\%https://www.kernel.org/doc/man\\-"
"pages/."
msgstr ""
